[["dinámica.html", "Capítulo 3 Dinámica 3.1 Transporte 3.2 Difusión 3.3 Oscilación", " Capítulo 3 Dinámica 3.1 Transporte Consideremos un grafo dirigido \\(G=(V,E)\\) y una familia de densidades \\(u(x,t)\\) que toma valores reales para cada vértice \\(x\\in V\\) en tiempo \\(t\\in\\mathbb R\\). Decimos que un flujo \\(f(e,t)\\) transporta a \\(u\\) si en cada instante salen \\(f(e,t)\\) unidades de masa de \\(e_-\\) hacia \\(e_+\\) por la arista \\(e\\). Es decir que sobre cada \\(x\\in V\\) se tiene que \\[ \\partial_t u(x,t) = \\sum_{e_+=x} f(e,t) - \\sum_{e_-=x} f(e,t) = -\\operatorname{div} f(x,t). \\] Observamos que si en un dado nodo \\(x\\in V\\) se tiene que \\(\\operatorname{div} f(x)&gt;0\\) entonces \\(u\\) es decreciente. Esto quiere decir que el flujo hace que la densidad se esparza o diverja sobre dicho nodo. De igual forma, si \\(\\operatorname{div} f(x)&lt;0\\), \\(u\\) es creciente y el flujo hace que la densidad en cambio converga en dicho nodo. Ejemplo 3.1 Consideremos una densidad \\(u:V\\times \\mathbb R\\to \\mathbb R\\) transportada por un flujo \\(f := \\mu u^-\\) donde \\(\\mu:E\\to \\mathbb R\\) son tazas de movilidad dadas sobre las aristas en el grafo a continuación y recordemos que \\(u^-(e)=u(e_-)\\) Comenzando de la distribución de densidades \\[ u(0) = (1,0,0,0) \\] integramos numericamente las cuatro ecuaciones dadas por \\[ \\partial_t u = -\\operatorname{div}(\\mu u^-) \\qquad\\Leftrightarrow \\qquad \\begin{cases} u(1)&#39; = -3u(1)+3u(3),\\\\ u(2)&#39; = u(1) - u(2),\\\\ u(3)&#39; = u(2) - 3u(3) + 2u(4),\\\\ u(4)&#39; = 2u(1)-2u(4). \\end{cases} \\] y obtenemos lo siguiente: import numpy as np import matplotlib.pyplot as plt import scipy as sp from scipy.integrate import odeint A = np.array([[-3, 0, 3, 0], [1, -1, 0, 0], [0, 1, -3, 2], [2, 0, 0, -2]]) def dudt(u,t): return np.matmul(A,u) u0 = np.array([1,0,0,0]) t = np.linspace(0,2,1000) sol = odeint(dudt,u0,t) plt.plot(t,sol[:,0], label=&#39;1&#39;) plt.plot(t,sol[:,1], label=&#39;2&#39;) plt.plot(t,sol[:,2], label=&#39;3&#39;) plt.plot(t,sol[:,3], label=&#39;4&#39;) plt.legend() plt.show() Adicionalmente podemos considerar modelos donde además del fenómeno de transporte, una o más densidades tienen distintas reacciones en cada uno de los nodos. Ejemplo 3.2 Las funciones \\(S,I:V\\to \\mathbb R\\) representan poblaciones de individuos susceptibles e infectados para una dada epidemia modelada geográficamente sobre un grafo dirigido \\(G=(V,E)\\). Cada una de estas poblaciones se mueve sobre las aristas por flujos dados por \\[ f_S := \\mu_S S^-, \\qquad f_I := \\mu_I I^-. \\] donde \\(\\mu_S,\\mu_I: E\\to \\mathbb R\\) son tazas de movilidad sobre las aristas. La dinámica de la epidemia en cada nodo está dada por las tazas de transmisión (\\(\\beta\\)) y recuperación (\\(\\gamma\\)). En específico planteamos el modelo de \\(2|V|\\) ecuaciones de primer orden no-lineales \\[ \\partial_t S = -\\beta SI + \\operatorname{div}(\\mu_S S^-), \\qquad \\partial_t I = \\beta SI - \\gamma I + \\operatorname{div}(\\mu_I I^-),\\\\ \\] Ejercicio 3.1 Demuestra que el total de la población susceptible o infectada es una función decreciente. Solución \\[ \\partial_t \\sum_{V} (S+I) = \\sum_{V} (-\\gamma I + \\operatorname{div} f_S+\\operatorname{div}f_I) = - \\gamma \\sum_{V} I \\leq 0. \\] Ejercicio 3.2 Considera una epidemia dada en la siguiente red con los parámetros dados. En las aristas se muestran ciertas tasas de movilidad, para los susceptibles estas deben multiplicarse por \\(10^{-2}\\) y para los infectados por \\(10^{-4}\\). Implementa numéricamente y grafica las soluciones en el intervalo \\([0,160]\\) con condiciones iniciales \\[ S(0) = (1,1,1,1), \\qquad I(0) = (0, 10^{-6},0,0). \\] Solución import numpy as np import matplotlib.pyplot as plt import scipy as sp from scipy.integrate import odeint beta = 0.5 gamma = 0.3 L = np.array([[-5, 1, 2, 1], [2, -3, 1, 0], [1, 2, -4, 2], [2, 0, 1, -3]]) def dSIdt(SI,t): S = SI[:4] I = SI[4:] dS = -beta*S*I + 0.01*np.matmul(L,S) dI = beta*S*I - gamma*I + 0.0001*np.matmul(L,I) return np.concatenate((dS,dI)) S0 = np.array([1,1,1,1]) I0 = np.array([0,0.00000001,0,0]) SI0 = np.concatenate((S0,I0)) t = np.linspace(0,160,1000) sol = odeint(dSIdt,SI0,t) fig, ax = plt.subplots(2,2,figsize=(10,5)) ax[0,0].plot(t,sol[:,0], label=&#39;S1&#39;) ax[0,0].plot(t,sol[:,4], label=&#39;I1&#39;) ax[0,0].legend() ax[1,0].plot(t,sol[:,1], label=&#39;S2&#39;) ax[1,0].plot(t,sol[:,5], label=&#39;I2&#39;) ax[1,0].legend() ax[0,1].plot(t,sol[:,2], label=&#39;S3&#39;) ax[0,1].plot(t,sol[:,6], label=&#39;I3&#39;) ax[0,1].legend() ax[1,1].plot(t,sol[:,3], label=&#39;S4&#39;) ax[1,1].plot(t,sol[:,7], label=&#39;I4&#39;) ax[1,1].legend() 3.2 Difusión Así como vimos en los ejemplos anteriores donde el flujo era proporcional a \\(u^-\\), en general puede darse el caso de que \\(f\\) esté determinada por alguna otra función de \\(u\\), esto se conoce como una ley constitutiva. Un caso muy común es que \\(f\\) sea proporcional a \\(-Du\\), en el cual obtenemos un modelo de difusión. Ejemplo 3.3 Sea \\(G=(V,E)\\) un grafo que modela una red de habitaciones en renta y \\(u:V\\times \\mathbb R\\to\\mathbb R\\) la población que vive en dicha red. Asumiendo la ley de oferta y demanda, el precio de renta \\(p=p(x,t)\\) de una habitación \\(x\\) en el instante \\(t\\) debe ser proporcional a la demanda, la cual podemos considerar en nuestro caso proporcional a la población que habita dicho nodo, digamos por ejemplo que \\(p = k_1u\\). La población busca moverse entre nodos adyacentes si percibe que el precio le es favorable, por ejemplo \\(f=-k_2Dp\\). Llegamos así a la ecuación \\[ \\partial_t u = -\\operatorname{div} f = \\operatorname{div}(k_2Dp) = \\operatorname{div}(aDu), \\qquad a := k_1k_2. \\] El problema \\(\\partial_t u = \\operatorname{div}(aDu)\\), también conocido como la ecuación de calor o difusión, representa un sistema de EDOs lineales y de primer orden con tantas ecuaciones e incógnitas como la cardinalidad de \\(V\\). Ejercicio 3.3 Considera una difusión de la forma \\(\\partial_t u = \\Delta u\\) sobre el siguiente grafo. Calcula \\(u\\) para todo tiempo dadas las condiciones iniciales ilustradas en la figura. ¿Converge la solución a algún punto fijo? Solución El sistema de 4 EDOs se presenta como \\[ \\frac{d}{dt}\\begin{pmatrix} u(a)\\\\ u(b)\\\\ u(c)\\\\ u(d) \\end{pmatrix} = \\begin{pmatrix} -3 &amp; 1 &amp; 1 &amp; 1\\\\ 1 &amp; -2 &amp; 1 &amp; 0\\\\ 1 &amp; 1 &amp; -3 &amp; 1\\\\ 1 &amp; 0 &amp; 1 &amp; -2 \\end{pmatrix}\\begin{pmatrix} u(a)\\\\ u(b)\\\\ u(c)\\\\ u(d) \\end{pmatrix} \\] Dada que la condición inicial es \\((1,0,0,0)^T\\) buscamos la primera columna de la matriz exponencial. El siguiente resultado se obtuvo con la ayuda de sympy, una librería de cálculo simbólico de python from sympy import * t = Symbol(&#39;t&#39;) mt = Matrix([[-3, 1, 1, 1], [1, -2, 1, 0], [1, 1, -3, 1], [1, 0, 1, -2]]) * t mexp = mt.exp() print(&#39;$$&#39; + latex(mexp) + &#39;$$&#39;) \\[\\left[\\begin{matrix}\\frac{1}{4} + \\frac{3 e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4}\\\\\\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} + \\frac{e^{- 2 t}}{2} + \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 2 t}}{2} + \\frac{e^{- 4 t}}{4}\\\\\\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} + \\frac{3 e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4}\\\\\\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 2 t}}{2} + \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} + \\frac{e^{- 2 t}}{2} + \\frac{e^{- 4 t}}{4}\\end{matrix}\\right]\\] Observamos que cuando \\(t\\to\\infty\\) la solución converge exponencialemente al vector \\((1/4,1/4,1/4,1/4)^T\\). De hecho esto sucede para cualquier condición incial. Ejercicio 3.4 Sea \\(G=(V,E)\\) un grafo lineal con 100 vértices \\[ V=\\{1,2,\\ldots,100\\}, \\qquad E = \\{(1,2),(2,3),\\ldots,(99,100)\\}. \\] Sea \\(u\\) solución de la ecuación de calor \\(\\partial_t u=\\Delta u\\) en \\(G\\) con condición inicial \\[ u(0) = e_{50} = (0,\\ldots,0,1,0,\\ldots,0). \\] Calcula el primer \\(t&gt;0\\) tal que \\(u(50,t)\\leq 0.1\\). Solución En este caso la dificultad está en cómo implementar el Laplaciano y encontrar el primer índice donde la solución baje de \\(0.1\\). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint Delta = -2*np.eye(100)+np.eye(100,k=1)+np.eye(100,k=-1) Delta[0,0] = -1 Delta[99,99] = -1 def dudt(u,t): return np.matmul(Delta,u) u0 = np.zeros(100) u0[49] = 1 t = np.linspace(0,20,1000) sol = odeint(dudt,u0,t) index = np.where(sol[:,49]&lt;0.1)[0][0] plt.plot(t,sol[:,49]) plt.plot(t[index],sol[index,49],&#39;ro&#39;,label=&quot;({:.2f},{:.2f})&quot;.format(t[index],sol[index,49])) plt.legend() plt.title(&quot;u(50,t)&quot;) plt.show() 3.3 Oscilación El sistema de EDOs lineales y de segundo orden dado por \\[ \\partial_t^2 u = \\operatorname{div}(aDu) \\] también es común en distintos modelos. Esta se conoce como la ecuación de onda. Ejemplo 3.4 Un grafo \\(G=(V,E)\\) modela las conexiones en un sistema de masas \\(m:V\\to (0,\\infty)\\) unidas por resortes con constantes \\(k:E\\to[0,\\infty)\\). Sea \\(q:V\\to \\mathbb R^n\\) los desplazamientos de las masas a partir de una configuración dada de equilibrio. A partir de la ley de Hooke planteamos el sistema \\(n\\times|V|\\) ecuaciones e incógnitas, \\[ m\\partial_t^2 q = \\operatorname{div}(kDq). \\] Recordemos que cualquier sistema de segundo orden puede ser llevado a un sistema de primer orden tomando a las velocidades como incógnitas del sistema. Por ejemplo, \\[ \\partial_t^2 u = \\operatorname{div}(aDu) \\qquad \\Leftrightarrow\\qquad \\begin{cases} \\partial_t u = v,\\\\ \\partial_t v = \\operatorname{div}(aDu). \\end{cases} \\] Ejemplo 3.5 El grafo \\(G=(V,E)\\) vuelve a modelar una red de habitaciones en renta, \\(u:V\\times \\mathbb R\\to\\mathbb R\\) la población que vive en dicha red y \\(p:V\\times \\mathbb R\\to\\mathbb R\\) los precios. Una vez más asumimos que la población se mueve según el flujo \\(f = -Dp\\). Por otro lado los precios se modifican gradualmente dependiendo de la demanda en relación a los nodos adyacentes. Esto último puede ser reflejado por ejemplo en la ecuación \\(\\partial_t p = -\\Delta u\\), es decir que el precio disminuye si el promedio de la población vecina es mayor la población en el nodo en consideración, con la intención de atraerla. En resumen obtenemos el sistema de ecuaciones \\[ \\partial_t u = \\Delta p, \\qquad \\partial_t p = -\\Delta u. \\] Estas implican las ecuaciones de onda desacopladas para el bilaplaciano \\[ \\partial_t^2 u = -\\Delta^2 u, \\qquad \\partial_t^2 p = -\\Delta^2p. \\] Ejercicio 3.5 Considera una oscilación de la forma \\(\\partial_t^2 u = -\\Delta^2 u\\) sobre el siguiente grafo. Calcula \\(u\\) para todo tiempo dadas las condiciones iniciales ilustradas en la figura, partiendo del reposo. Grafica la solución en el intervalo \\([0,6]\\). Solución El sistema de 4 EDOs se presenta como \\[ \\frac{d}{dt}\\begin{pmatrix} u(a)\\\\ u(b)\\\\ u(c)\\\\ u(d)\\\\ u&#39;(a)\\\\ u&#39;(b)\\\\ u&#39;(c)\\\\ u&#39;(d) \\end{pmatrix} = \\begin{pmatrix} 0_4 &amp; I_4\\\\ -\\Delta^2 &amp; 0_4 \\end{pmatrix}\\begin{pmatrix} u(a)\\\\ u(b)\\\\ u(c)\\\\ u(d)\\\\ u&#39;(a)\\\\ u&#39;(b)\\\\ u&#39;(c)\\\\ u&#39;(d) \\end{pmatrix}, \\qquad \\Delta = \\begin{pmatrix} -3 &amp; 1 &amp; 1 &amp; 1\\\\ 1 &amp; -2 &amp; 1 &amp; 0\\\\ 1 &amp; 1 &amp; -3 &amp; 1\\\\ 1 &amp; 0 &amp; 1 &amp; -2 \\end{pmatrix} \\] Para calcular la solución analítica usamos el paquete simbólico de python. import numpy as np import matplotlib.pyplot as plt import sympy as smp from sympy.plotting import plot Delta = smp.Matrix([[-3,1,1,1], [1,-2,1,0], [1,1,-3,1], [1,0,1,-2]]) t = smp.symbols(&#39;t&#39;,real=&#39;True&#39;) B = smp.Matrix(smp.BlockMatrix([[smp.ZeroMatrix(4,4),smp.Identity(4)], [-Delta*Delta,smp.ZeroMatrix(4,4)]]))*t eB = smp.re(B.exp()) y0 = smp.Matrix([0,1,2,3,0,0,0,0]) y_s = eB*y0 print(&#39;$$&#39; + smp.latex(y_s[:4]) + &#39;$$&#39;) \\[\\left[ \\frac{3}{2} - \\frac{3 \\cos{\\left(4 t \\right)}}{2}, \\ - \\cos{\\left(2 t \\right)} + \\frac{\\cos{\\left(4 t \\right)}}{2} + \\frac{3}{2}, \\ \\frac{\\cos{\\left(4 t \\right)}}{2} + \\frac{3}{2}, \\ \\cos{\\left(2 t \\right)} + \\frac{\\cos{\\left(4 t \\right)}}{2} + \\frac{3}{2}\\right]\\] Las gráficas están dadas por eB_f = smp.lambdify(t,eB) t = np.linspace(0,6,600) y0 = np.array([0,1,2,3,0,0,0,0]) y = np.einsum(&#39;ijk,j-&gt;ik&#39;,eB_f(t),y0) plt.plot(t,y[0,:],label=&#39;a&#39;) plt.plot(t,y[1,:],label=&#39;b&#39;) plt.plot(t,y[2,:],label=&#39;c&#39;) plt.plot(t,y[3,:],label=&#39;d&#39;) plt.legend(loc=&#39;lower right&#39;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
