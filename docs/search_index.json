[["index.html", "Métodos de matemáticas aplicadas Prefacio", " Métodos de matemáticas aplicadas Héctor Andrés Chang-Lara 2022-08-12 Prefacio Hola "],["entramados.html", "Capítulo 1 Entramados", " Capítulo 1 Entramados La siguiente figura ilustra cuatro puntos masivos unidos por tres barras de longitudes conocidas \\(\\ell_{01}, \\ell_{12}, \\ell_{23}\\), y masas despreciables. Los extremos etiquetados por \\(0\\) y \\(3\\) tienen posiciones fijas y los nodos intermedios de masas \\(m_1\\) y \\(m_2\\) ocupan posiciones de equilibrio. ¿A partir de cuales ecuaciones se podrían determinar las posiciones \\(q_i=(x_i,y_i)\\) de estos nodos? Antes de proceder a plantear el sistema de ecuaciones recordemos que por lo general el número de ecuaciones e incógnitas deben ser iguales para que este esté bien planteado, es decir que existan soluciones y que sean únicas (al menos localmente). En nuestro caso tenemos cuatro incógnitas, los dos pares de coordenadas de cada nodo libre. Además debemos considerar las restricciones impuestas por las distancias entre los nodos, es decir tres ecuaciones. Hasta el momento el sistema es indeterminado, tiene más incógnitas (4) que ecuaciones (3), sin embargo aún nos falta incorporar la información del fenómeno de equilibrio. \\[ \\begin{cases} (x_1-0)^2 + (y_1-0)^2 = \\ell_{01}^2\\\\ (x_1-x_2)^2 + (y_1-y_2)^2 = \\ell_{12}^2\\\\ (x_2-3)^2 + (y_2-0)^2 = \\ell_{23}^2 \\end{cases} \\] En cada nodo libre actúan tres fuerzas: dos tensiones y la gravedad \\((= -m_ige_y)\\). Por ejemplo, la tensión \\(T_{12}\\) sobre el nodo 1 y que se produce sobre el segmento que une los nodos 1 y 2 es proporcional al vector \\(q_2-q_1\\), es decir \\(T_{12} = \\lambda_{12} (q_2-q_1)\\) para un cierto escalar \\(\\lambda_{12}\\). Similarmente podemos razonar sobre las demás interacciones, introduciendo así cuatro nuevas variables \\(\\lambda_{10}, \\lambda_{12}, \\lambda_{21}\\), y \\(\\lambda_{23}\\). Para que el sistema se encuentre en equilibrio, la suma de las fuerzas sobre cada nodo debe anularse, lo cual nos da igualmente cuatro ecuaciones: \\[ \\begin{cases} \\lambda_{10}(x_{0}-x_{1})+\\lambda_{12}(x_{2}-x_{1}) = 0\\\\ \\lambda_{10}(y_{0}-y_{1})+\\lambda_{12}(y_{2}-y_{1}) = m_{1}g\\\\ \\lambda_{23}(x_{3}-x_{2})+\\lambda_{21}(x_{1}-x_{2}) = 0\\\\ \\lambda_{23}(y_{3}-y_{2})+\\lambda_{21}(y_{1}-y_{2}) = m_{2}g \\end{cases} \\] Pareciera que no hemos logrado mucho en términos del sistema que sigue siendo indeterminado con ocho incógnitas (2 \\(x\\)’s, 2 \\(y\\)’s y 4 \\(\\lambda\\)’s) y siete ecuaciones (3 distancias y 4 balances de fuerzas). Sin embargo, la tercera ley de Newton nos dice que las interacciones entre pares de nodos guarda una simetría: toda acción produce una reacción opuesta de la misma magnitud. En nuestro modelo esto se refleja en \\(T_{12} = -T_{21}\\), de donde obtenemos la última ecuación \\[ \\lambda_{12}=\\lambda_{21}. \\] De hecho es más sencillo eliminar una de las incógnitas (\\(\\lambda_{21}\\)) que añadir otra ecuación. En conclusión obtenemos el siguiente sistema con siete ecuaciones e incógnitas \\[ \\begin{cases} \\lambda_{10}(x_{0}-x_{1})+\\lambda_{12}(x_{2}-x_{1}) = 0\\\\ \\lambda_{10}(y_{0}-y_{1})+\\lambda_{12}(y_{2}-y_{1}) = m_{1}g\\\\ \\lambda_{23}(x_{3}-x_{2})+\\lambda_{12}(x_{1}-x_{2}) = 0\\\\ \\lambda_{23}(y_{3}-y_{2})+\\lambda_{12}(y_{1}-y_{2}) = m_{2}g\\\\ (x_1-0)^2 + (y_1-0)^2 = \\ell_{01}^2\\\\ (x_1-x_2)^2 + (y_1-y_2)^2 = \\ell_{12}^2\\\\ (x_2-3)^2 + (y_2-0)^2 = \\ell_{23}^2 \\end{cases} \\] Una forma de obtener solución a este sistema es el método de Newton. Por ejemplo, para los valores \\(\\ell_{01}=\\sqrt{5}, \\ell_{12}=\\sqrt{5}, \\ell_{23}=\\sqrt{10}, m_1=1, m_2=2, q_0=(0,0), q_3=(4,0)\\) la siguiente implementación ilustra como obtener la solución usando Python1. #Librerías import matplotlib.pyplot as plt import numpy as np from scipy.optimize import fsolve #Parámetros l01=np.sqrt(5) l12=np.sqrt(5) l23=np.sqrt(10) x3,y3=4,0 m1=1 m2=2 #Sistema de ecuaciones y gráfica def f(x): x1,y1,x2,y2,lambda01,lambda12,lambda23 = x f=np.zeros(7) f[0] = x1**2+y1**2-l01**2 f[1] = (x2-x1)**2+(y2-y1)**2-l12**2 f[2] = (x3-x2)**2+(y3-y2)**2-l23**2 f[3] = -lambda01*x1+lambda12*(x2-x1) f[4] = -lambda01*y1+lambda12*(y2-y1)-m1 f[5] = lambda12*(x1-x2)+lambda23*(x3-x2) f[6] = lambda12*(y1-y2)+lambda23*(y3-y2)-m2 return f r = fsolve(f,[1,-1,3,-2,0,0,0]) x1,y1=r[0],r[1] x2,y2=r[2],r[3] fig, ax = plt.subplots() ax.plot([0,r[0],r[2],x3], [0,r[1],r[3],y3]) ax.plot(0,0,color=&#39;tab:blue&#39;, marker=&#39;o&#39;, label=&#39;$q_0=(0,0)$&#39;) ax.plot(x1,y1,color=&#39;tab:orange&#39;, marker=&#39;o&#39;, label=&quot;$q_1=({:.4f},{:.4f})$&quot;.format(x1, y1)) ax.plot(x2,y2,color=&#39;tab:green&#39;, marker=&#39;o&#39;, label=&quot;$q_1=({:.4f},{:.4f})$&quot;.format(x2, y2)) ax.plot(x3,y3,color=&#39;tab:red&#39;, marker=&#39;o&#39;, label=&quot;$q_1=({},{})$&quot;.format(x3, y3)) leg = ax.legend(); plt.show() Estas ideas son fácilmente generalizables a configuraciones lineales con más nodos. En el límite se obtiene el problema de la catenaria. También podemos considerar estructuras más complejas, por ejemplo un pañuelo sujeto por las esquinas. Para poder dar una generalización de estos modelos presentamos en la siguiente sección algunas nociones básicas de teoría de grafos. Una referencia entretenida con aplicaciones en arquitectura está en el siguiente enlace: Diseñar estructuras… ¿sin cálculos?  La magia de la CATENARIA Ejercicio 1.1 Calcula \\(m_2\\) para que el entramado esté en equilibrio dado que los nodos en \\((0,0)\\) y \\((13,0)\\) están fijos Solución Las fuerzas en el nodo \\(1\\) están dadas por \\[ \\begin{cases} 5\\lambda_{01}=6\\lambda_{12},\\\\ 8\\lambda_{01}+\\lambda_{12}=g \\end{cases} \\qquad\\Rightarrow\\qquad \\lambda_{01}=\\frac{6g}{53}, \\lambda_{12}=\\frac{5g}{53} \\] Las fuerzas en el nodo \\(2\\) están dadas por \\[ \\begin{cases} 6\\lambda_{12}=2\\lambda_{23},\\\\ -\\lambda_{12}+7\\lambda_{23}=m_2g \\end{cases} \\qquad\\Rightarrow\\qquad \\lambda_{23}=\\frac{15g}{53}, m_2=\\frac{100}{53}. \\] Ejercicio 1.2 Demuestra que si un dado entramado como en la figura, y con extremos en el eje horizontal, está en equilibro, entonces su correspondiente reflexión en el eje horizontal también está en equilibrio. ¿Será posible generalizar este principio a un entramado general? Solución Denotamos por \\(\\lambda_i=\\lambda_{i,i-1} = -\\lambda_{i-1,i}\\). En cada nodo del entramado original se tiene el balance de fuerzas está dado por \\[ \\begin{cases} (x_i-x_{i-1})\\lambda_i=(x_{i+1}-x_{i})\\lambda_{i+1},\\\\ (y_{i-1}-y_{i})\\lambda_i+(y_{i+1}-y_{i})\\lambda_{i+1}=m_ig \\end{cases} \\] Al tomar la reflexión en el eje horizontal las coordenadas de los nodos pasan a ser \\((x_i,y_i)\\mapsto (x_i&#39;,y_i&#39;) = (x_i,-y_i)\\). Gracias a las relaciones previas, se observa que estas coordenadas satisfacen igualmente las ecuaciones de balance de fuerzas cuando igualmente reemplazamos \\(\\lambda_i\\mapsto \\lambda_i&#39; =-\\lambda_i\\) \\[ \\begin{cases} (x_i&#39;-x_{i-1}&#39;)\\lambda_i&#39;=(x_{i+1}&#39;-x_{i}&#39;)\\lambda_{i+1}&#39;,\\\\ (y_{i-1}&#39;-y_{i}&#39;)\\lambda_i&#39;+(y_{i+1}&#39;-y_{i}&#39;)\\lambda_{i+1}&#39;=m_ig. \\end{cases} \\] Este principio se generaliza a un entramado general con una notación adecuada. Advertencia: El código es sensible a las condiciones iniciales para la iteración y no siempre converge.↩︎ "],["cálculo-discreto.html", "Capítulo 2 Cálculo discreto 2.1 Gradiente 2.2 Divergencia 2.3 Integración por partes 2.4 Laplaciano", " Capítulo 2 Cálculo discreto Una grafo dirigido \\(G = (V,E)\\) consiste de un conjunto de vértices \\(V\\), también llamados nodos, y un conjunto de aristas \\(E \\subseteq V^2\\), es decir pares ordenados de \\(V\\). Dado \\(e = (a,b)\\in E\\), denotamos por \\(e_-=a\\) y \\(e_+=b\\) los nodos de partida y llegada de \\(e\\) respectivamente y decimos que \\(e\\) está orientado de \\(a\\) a \\(b\\). En general trabajaremos con grafos con aristas simples, es decir que a lo sumo existe una arista que conecta dos vértices en cualquier orientación. Sin embargo, cuando \\(e=(a,b)\\in E\\) podríamos hacer referencia a la arista \\(-e=(b,a)\\) como la arista \\(e\\) con el sentido opuesto. Finalmente, podemos considerar también conjuntos de aristas no orientadas en cuyo caso decimos que el grafo es no dirigido. Ejercicio 2.1 Dibuja el grafo \\(G=(V,E)\\) para \\[ V = \\{1,2,3,a,b,c\\}, \\qquad E = \\{(1,a),(1,b),(1,c),(2,a),(2,b),(2,c),(3,a),(3,b),(3,c)\\}. \\] Solución Las redes eléctricas son uno de los modelos más conocidos que se pueden formular en términos de grafos. Sobre el grafo podemos caracterizar por ejemplo el potencial o voltaje como una función \\(u:V\\to \\mathbb R\\) y la corriente como una función \\(i:E\\to \\mathbb R\\). Siguiendo un poco la nomenclatura que sugiere este modelo, distinguimos dos tipos de funciones en \\(G\\): Potencial: Es una función sobre el conjunto de vértices \\(u: V \\to \\mathbb R\\). Flujo: Es una función sobre el conjunto de aristas \\(f: E \\to \\mathbb R\\). En algunos casos también podríamos considerar que dichas funciones tomen valores en \\(\\mathbb C\\), \\(\\mathbb R^n\\) ó \\(\\mathbb C^n\\). Cuando \\(G\\) es un grafo dirigido, decimos que \\(f:E\\to\\mathbb R\\) es par cuando no depende de la orientación \\(f(-e) = f(e)\\), y decimos que impar si en cambio \\(f(-e) = -f(e)\\). Una función \\(f:E\\to\\mathbb R\\) en un grafo no dirigido es equivalente a una función par en el mismo grafo y con cualquier orientación sobre las aristas. Ejemplo 2.1 En el modelo de entramados en la sección anterior, el grafo no dirigido \\(G=(V,E)\\) con \\(V = \\{0,1,2,3\\}\\) y \\(E=\\{\\{0,1\\},\\{1,2\\},\\{2,3\\}\\}\\) nos proporciona la información sobre cuales nodos están conectados entre si. Las posiciones de los nodos se caracterizan por \\(q:V\\to \\mathbb R^2\\) y las longitudes de los enlaces están determinadas por \\(\\ell:E\\to\\mathbb R\\). Para modelar las tensiones es conveniente considerar el grafo dirigido \\(G=(V,E&#39;)\\) de alguna forma arbitraria, quizás \\(E&#39;=\\{(0,1),(1,2),(2,3)\\}\\). De esta forma contamos con la función par \\(\\lambda:E&#39;\\to\\mathbb R\\) y la función impar \\(T: E&#39; \\to \\mathbb R^2\\) tales que \\[ T(e) = \\lambda(e)(q(e_+)-q(e_-)) \\] es la tensión sobre el nodo \\(e_-\\) a lo largo de \\(e\\). A su vez y gracias a la ley de acción y reacción, \\(T(-e) = -T(e)\\) es la tensión sobre el nodo \\(e_+\\) a lo largo de \\(e\\) pero en la orientación opuesta, es decir \\(-e\\). Ejemplo 2.2 Un potencial \\(u:V\\to\\mathbb R\\) sobre una red de resistencia genera una corriente \\(i:E\\to \\mathbb R\\) que modelamos usando la ley de Ohm para una dada resistencia \\(R:E\\to (0,\\infty)\\) (función par). Esto quiere decir que la corriente \\(i(e)\\) que atraviesa una arista \\(e = (e_-,e_+)\\) es proporcional a la diferencia de los potenciales en los extremos de la arista \\[ i(e) = \\frac{u(e_+) - u(e_-)}{R(e)}, \\qquad R(e) &gt;0: \\text{ Resistencia.} \\] 2.1 Gradiente Tanto en la construcción de las tensiones \\(T\\), como en la de la corriente eléctrica \\(i\\), estamos considerando la variación de una dada función (las posiciones \\(q\\) ó el potencial \\(u\\)) a lo largo de una arista dada. Esto es una versión discreta de la derivada direccional. En este caso requerimos que el grafo sea orientado. Definición 2.1 Dado potencial \\(u:V\\to\\mathbb R\\) sobre un grafo dirigido \\(G=(V,E)\\), definimos el gradiente \\(Du: E \\to \\mathbb R\\) tal que \\[ Du(e) = u(e_{+})-u(e_{-}). \\] En particular, el gradiente es una función impar. Ejercicio 2.2 Calcula el gradiente de la función dada en los vértices del siguiente grafo Solución Ejercicio 2.3 Verifica que el gradiente satisface la identidad de Leibniz \\[ D(u_1u_2) = u_1^+ Du_2 + u_2^-Du_1 \\] donde \\(u^\\pm:E\\to\\mathbb R\\) se define a partir de \\(u:V\\to\\mathbb R\\) como \\(u^\\pm(e) = u(e_\\pm)\\). Solución \\[ \\begin{aligned} D(u_1u_2)(e) &amp;= u_1(e_+)u_2(e_+) - u_1(e_-)u_2(e_-),\\\\ &amp;= u_1(e_+)u_2(e_+) - u_1(e_+)u_2(e_-) + u_1(e_+)u_2(e_-) - u_1(e_-)u_2(e_-),\\\\ &amp;= u_1(e_+)(u_2(e_+)-u_2(e_-)) + u_2(e_-)(u_1(e_+)-u_1(e_-)),\\\\ &amp;= u_1(e_+)Du_2(e) + u_2(e_-)Du_1(e),\\\\ &amp;= (u_1^+Du_2 + u_2^-Du_1)(e). \\end{aligned} \\] 2.1.1 Ley de ciclos No toda función \\(f:E\\to \\mathbb R\\) es necesariamente un gradiente. Una condición necesaria y suficiente es la ley de ciclos. Para poder enunciar esta ley es conveniente dar algunas definiciones previas para un dado grafo dirigido \\(G=(V,E)\\). Definición 2.2 Un camino no orientado es una sucesión de vértices \\(x_0,x_1, \\dots, x_n \\in V\\) tal que \\((x_j,x_{j+1})\\) o \\((x_{j+1},x_{j})\\) es una arista en \\(E\\) para todo \\(j\\in\\{0,1,\\ldots,(n-1)\\}\\). Se dice que el camino es un ciclo si además \\(x_n=x_0\\). Definición 2.3 Una componente conexa de \\(G\\) es un subconjunto \\(V&#39;\\subseteq V\\) tal que: Todos los vértices en \\(V&#39;\\) están conectados entre si por algún camino. Ningún vértice de \\(V&#39;\\) está conectado con ningún vértice de \\(V\\setminus V&#39;\\). Decimos que \\(G\\) es conexo si tiene una única componente conexa. Teorema 2.1 (Ley de ciclos) Sea \\(G=(V,E)\\) un grafo dirigido finito. Una función impar \\(f:E\\to\\mathbb R\\) es igual al gradiente de una función \\(u:V\\to \\mathbb R\\) si y solo si para todo ciclo \\(x_0,x_1, \\dots, x_n=x_0\\) se tiene que \\[ \\sum_{j=0}^{n-1} f(x_j,x_{j+1}) = 0. \\] Demostración. Por un lado es fácil verificar la identidad para flujos gradientes usando la propiedad telescópica. Dado un ciclo \\(x_0,x_1, \\dots, x_n=x_0\\) \\[ \\sum_{j=0}^{n-1} Du(x_j,x_{j+1}) = \\sum_{j=0}^{n-1} (u(x_{j+1})-u(x_j)) = u(x_n)-u(x_0)=0. \\] Podemos construir \\(u:V&#39;\\to \\mathbb R\\) sobre cada una de las componentes conexas de \\(G\\) procedemos de la siguiente forma. Fijemos \\(x_0 \\in V&#39;\\) y definimos \\[ u(x) := \\sum_{j=0}^{n-1} f(x_j,x_{j+1}) \\] donde \\(x_0,x_1, \\dots, x_n=x\\) es un camino no orientado que conecta \\(x_0\\) con \\(x\\in V&#39;\\). La hipótesis dada por la ley de ciclos garantiza que esta construcción no depende del camino escogido, es decir que está bien definida sin posible ambigüedad: Dados dos caminos \\(x_0,\\ldots,x_n=x\\) y \\(y_0=x_0,\\ldots,y_m=x\\) se tiene que \\(z_0=x_0,\\ldots,z_n=x_n,z_{n+1}=y_{m-1},\\ldots,z_{n+m}=y_0\\) es un ciclo y por lo tanto \\[ 0 = \\sum_{j=0}^{n+m-1} f(z_j,z_{j+1}) = \\sum_{j=0}^{n-1} f(x_j,x_{j+1}) - \\sum_{j=0}^{m-1} f(y_j,y_{j+1}). \\] Veamos finalmente que \\(Du = f\\). Dado \\(e\\in E\\) con \\(e_\\pm\\) en la misma componente que \\(x_0\\), tomamos un camino \\(x_0,x_1,\\ldots, x_n=e_-\\) de \\(x_0\\) a \\(e_-\\) y luego añadimos \\(x_{n+1}=e_+\\) para formar un camino de \\(x_0\\) a \\(e_+\\). Por lo tanto \\[ Du(e) = u(e_+)-u(e_-) = \\sum_{j=0}^{n} f(x_j,x_{j+1})-\\sum_{j=0}^{n-1} f(x_j,x_{j+1}) = f(e), \\] con lo cual concluímos la demostración. Este argumento nos permite apreciar que \\(u\\) está únicamente determinado salvo potenciales constantes en cada componente conexa de \\(G\\). Las constantes son los valores arbitrarios que daríamos a \\(u\\) sobre el nodo \\(x_0\\), que en nuestra demostración fue cero. Ejercicio 2.4 Calcula los potenciales que generan el flujo dado en la siguiente figura Solución El flujo satisface la ley de ciclos. Por ejemplo en el triángulo de la izquierda la suma correspondiente es \\(-3+1+2=0\\) y de igual forma podemos verificar en el triángulo de la derecha (\\(2+(-1)+(-1)=0\\)) o en el cuadrado exterior (\\((-3)+1-(-1)-(-1)=0\\)). Si tomamos \\(u(A)=0\\) sin pérdida de generalidad tenemos que \\[ \\begin{cases} u(B) = 1 + u(A) = 1,\\\\ u(C) = 3 + u(A) = 3,\\\\ u(D) = -1 + u(C) = 2. \\end{cases} \\] Verificamos además que con estos valores se obtiene el gradiente prescrito \\[ \\begin{cases} Du(AB) = u(B)-u(A) = 1-0 = 1,\\\\ Du(BC) = u(C)-u(B) = 3-1 = 2,\\\\ Du(CA) = u(A)-u(C) = 0-3 = -3,\\\\ Du(CD) = u(D)-u(C) = 2-3 = -1,\\\\ Du(DB) = u(B)-u(D) = 1-2 = -1. \\end{cases} \\] En general, \\(u\\) tiene el gradiente prescrito si y solo si \\[ u(A) = C, \\qquad u(B) = 1+C, \\qquad u(C) = 3+C, \\qquad u(D)=2+C. \\] Margen de cálculo: El lema de Poincaré Como ya el lector habrá notado, estas construcciones y propiedades encuentran paralelos en cálculo multivariable, y de hecho las demostraciones reproducen las mismas ideas: Los caminos son curvas, los ciclos son lazos o curvas cerradas y la expresión \\(\\sum_{j=0}^{n-1} f(x_j,x_{j+1})\\) es análoga a la integral de línea o el trabajo de un campo vectorial sobre una curva. El resultado que acabamos de enunciar se conoce como el Lema de Poincaré global. Recordemos su enunciado junto con el resultado local. Lema de Poincaré (global): Un campo vectorial \\(f \\in C(\\Omega\\subseteq\\mathbb R^n\\to\\mathbb R^n)\\) es el gradiente de algún potencial \\(u\\in C^1(\\Omega\\to\\mathbb R)\\) si y sólo si para cualquier curva cerrada \\(\\gamma \\in C^1([a,b]\\to\\Omega)\\) (i.e. \\(\\gamma(b)=\\gamma(a)\\)) se tiene que el trabajo que ejerce \\(f\\) sobre la curva \\(\\gamma\\) se anula \\[ \\int_\\gamma f = \\int_a^b f(\\gamma(t))\\cdot \\gamma&#39;(t)dt = 0. \\] Lema de Poincaré (local): Si \\(\\Omega\\subseteq\\mathbb R^n\\) es simplemente conexo2 entonces \\(f \\in C^1(\\Omega\\to\\mathbb R^n)\\) es un gradiente si y solo si \\(\\partial_if_j = \\partial_jf_i\\). 2.2 Divergencia Otro operador diferencial que tiene su análogo en grafos es la divergencia. Heurísticamente, la divergencia de un campo vectorial mide cuando es positiva la cantidad de flujo que sale o diverge del nodo dado, mientras que cuando es negativa mide la cantidad de flujo que recibe o converge en el nodo. Definición 2.4 Dado \\(f: E \\to \\mathbb R\\) denotamos por \\(\\operatorname{div} f:V\\to \\mathbb R\\) a la divergencia de \\(f\\) donde \\[ \\operatorname{div} f(v) = \\sum_{e_-=v}f(e)-\\sum_{e_+=v}f(e) \\] Ejemplo 2.3 En la siguiente figura se calculó la divergencia de la función dada en las aristas Ejemplo 2.4 Las ecuaciones de balance para un entramado se escriben en términos de la divergencia de las tensiones sobre los nodos libres como \\[ \\operatorname{div} T = -mge_y \\] Ejemplo 2.5 La ley de Kirchhoff dice que en en un nodo que no está conectado a la batería, la corriente que entra y sale de este son iguales. En términos de la divergencia quiere decir que \\[ \\operatorname{div} i = 0 \\] 2.2.1 Fórmula de la divergencia Al igual que antes, podríamos preguntarnos si todo potencial es la divergencia de algún campo. Esto no es necesariamente cierto, la divergencia satisface la ley de conservación, análoga al teorema de la divergencia. Un caso particular ilustrativo de esta ley postula que la suma de la divergencia sobre un grafo finito es igual a cero \\[ \\sum_{v\\in V} \\operatorname{div} f(v) = 0. \\] Una vez más la justificación se basa en una propiedad telescópica para la suma: Cada arista aparece dos veces en la suma con signos opuestos dependiendo si se considera su vértice origen o de llegada. Para dar una versión discreta del teorema de la divergencia consideramos el campo normal exterior \\(n_\\Omega:E\\to \\mathbb R\\) tal que \\[ n_\\Omega(e) = \\begin{cases} +1 \\text{ si $e_-\\in \\Omega$ y $e_+\\in V\\setminus \\Omega$},\\\\ -1 \\text{ si $e_-\\in V\\setminus \\Omega$ y $e_+\\in \\Omega$},\\\\ 0 \\text{ en cualquier otro caso} \\end{cases} \\] en este caso el signo de \\(n_\\Omega(e)\\) indica cuando la arista orientada conecta a \\(\\Omega\\) con su complemento o viceversa. Ejercicio 2.5 El campo normal es el gradiente de una dada función ¿Cuál?. Solución \\(n_\\Omega = D1_{V\\setminus \\Omega}\\) donde \\[ 1_{V\\setminus \\Omega}(x) = \\begin{cases} 1 \\text{ si } x\\in V\\setminus \\Omega,\\\\ 0 \\text{ en cualquier otro caso}. \\end{cases} \\] Teorema 2.2 (Fórmula de la divergencia) Sea \\(G=(V,E)\\) un grafo dirigido finito. La divergencia de \\(f:E\\to \\mathbb R\\) verifica \\[\\begin{equation} \\sum_{v\\in \\Omega} \\operatorname{div} f(v) = \\sum_{e\\in E} f(e)n_\\Omega(e) \\tag{2.1} \\end{equation}\\] De hecho la suma en el lado derecho ocurre en realidad sobre un subconjunto de aristas que podemos definir como el borde de \\(\\partial\\Omega\\) \\[ \\partial \\Omega := \\{e\\in E\\ | \\ \\{e_+,e_-\\} \\cap \\Omega \\neq \\emptyset \\text{ y } \\{e_+,e_-\\} \\cap E\\setminus \\Omega \\neq \\emptyset\\} \\] es decir las aristas que conectan \\(\\Omega\\) con su complemento en cualquier orientación. La cantidad \\(f(e)n_\\Omega(e)\\) es positiva cuando \\(e_-\\in \\Omega\\), \\(e_+\\in V\\setminus \\Omega\\) y \\(f(e)&gt;0\\); o bien cuando \\(e_-\\in V\\setminus \\Omega\\), \\(e_+\\in \\Omega\\) y \\(f(e)&lt;0\\). En cualquier caso, \\(f(e)n_\\Omega(e)\\) se interpreta como la cantidad de masa que escapa de \\(\\Omega\\) por medio de \\(e\\). Un razonamiento similar se dá cuando \\(f(e)n_\\Omega(e)\\) es negativo para la masa que entra. El balance total nos dice que la masa que se produce o absorbe en \\(\\Omega\\) se puede medir de dos formas, sumando las divergencias en \\(\\Omega\\) u observando las contribuciones que escapan o entran por las aristas que conectan a \\(\\Omega\\) con su complemento \\(V\\setminus \\Omega\\) en cualquier orientación. Demostración. Sean \\(1_\\pm:V\\times E\\to \\mathbb R\\) definidas según \\[ 1_\\pm(v,e) := \\begin{cases} 1 \\text{ si } e_\\pm = v,\\\\ 0 \\text{ en cualquier otro caso}. \\end{cases} \\] En particular usaremos que \\[ \\sum_{v\\in \\Omega} 1_\\pm(v,e) = \\begin{cases} 1 \\text{ si } e_\\pm \\in \\Omega,\\\\ 0 \\text{ encualquier otro caso} \\end{cases} \\] Tenemos así que \\[ \\begin{aligned} \\sum_{v\\in \\Omega} \\operatorname{div} f(v) &amp;= \\sum_{v\\in \\Omega} \\sum_{e_-=v} f(e) - \\sum_{v\\in \\Omega} \\sum_{e_+=v} f(e),\\\\ &amp;= \\sum_{v\\in \\Omega} \\sum_{e \\in E} f(e)1_-(v,e) - \\sum_{v\\in \\Omega} \\sum_{e \\in E} f(e)1_+(v,e),\\\\ &amp;= \\sum_{e \\in E} \\sum_{v\\in \\Omega}f(e)1_-(v,e) - \\sum_{e \\in E} \\sum_{v\\in \\Omega}f(e)1_+(v,e),\\\\ &amp;= \\sum_{e_-\\in \\Omega} f(e) -\\sum_{e_+\\in \\Omega} f(e),\\\\ &amp;= \\sum_{\\substack{e_-\\in \\Omega\\\\e_+\\in V\\setminus \\Omega}} f(e) + \\sum_{e_-, e_+\\in \\Omega} f(e) - \\sum_{\\substack{e_+\\in \\Omega\\\\e_-\\in V\\setminus \\Omega}} f(e) - \\sum_{e_-, e_+\\in \\Omega} f(e),\\\\ &amp;= \\sum_{\\substack{e_-\\in \\Omega\\\\e_+\\in V\\setminus \\Omega}} f(e) - \\sum_{\\substack{e_+\\in \\Omega\\\\e_-\\in V\\setminus \\Omega}} f(e) \\end{aligned} \\] Esta última expresión es por definición de \\(n_\\Omega\\) igual a \\[ \\sum_{e\\in E} f(e)n_\\Omega(e), \\] con lo cual se concluye la demostración. Margen de cálculo: El teorema de la divergencia El teorema de la divergencia nos dice que dado un subconjunto \\(\\Omega \\subset\\mathbb R^n\\) con frontera localmente de clase \\(C^1\\) a trozos, y campo \\(v\\in C^1(\\overline{\\Omega}\\to\\mathbb R^n)\\), entonces \\[ \\int_\\Omega \\operatorname{div} v = \\int_{\\partial \\Omega} v\\cdot n \\] donde \\(n\\) es el vector normal exterior a \\(\\Omega\\). El lado derecho integra el flujo que escapa o entra en \\(\\Omega\\) a través de su borde. En concreto, si en un punto dado del borde \\(v\\cdot n &gt;0\\) entonces \\(v\\) apunta en la dirección de \\(n\\) y el flujo escapa con una tasa igual a \\(v\\cdot n\\), si en cambio \\(v\\cdot n &lt; 0\\) el flujo estaría entrando, y si \\(v\\cdot n=0\\) se tiene que \\(v\\) es tangente y el flujo apenas roza la superficie. El lado izquierdo de la expresión es una integral sobre \\(\\Omega\\) que representa la producción/absorción de flujo por el campo \\(v\\). 2.2.2 Lema de Poincaré para la divergencia Teorema 2.3 Sea \\(G=(V,E)\\) un grafo dirigido finito. Para cualquier \\(\\mu:V\\to\\mathbb R\\) tal que \\[ \\sum_{x\\in V}\\mu(x)=0 \\] existe por lo menos una solución \\(i:E\\to\\mathbb R\\) de \\[ \\operatorname{div} f = \\mu. \\] Demostración. Asumamos sin pérdida de generalidad que \\(G\\) es conexo. Tomemos un nodo arbitrario \\(x_0\\in V\\) y consideremos inductivamente caminos no orientados que vayan conectando a \\(x_0\\) con cada uno de los nodos restantes y de tal forma que nunca se formen ciclos en esta construcción. Es decir, estamos proponiendo un árbol generador del grafo con raíz en el nodo \\(x_0\\), es decir un sub-grafo de \\(G\\) libre de ciclos que conecta a todos los vértices. Fijamos \\(f=0\\) en las aristas que no pertenecen a los caminos señalados y en los demás ajustaremos \\(f\\) para que satisfaga la ecuación dada. La idea ahora consiste en ir tomando distintas ramas del árbol e ir asignando \\(f\\) convenientemente como una función impar. Sea por ejemplo \\(y_1,\\ldots,y_k\\) una rama, donde \\(y_1\\) es una hoja, es decir un nodo del árbol con un único nodo adyacente en el árbol (\\(y_2\\)). Tomemos \\(e_j = (y_j,y_{j+1})\\) y vamos fijando \\(f\\) recursivamente tal que \\[ f(e_{j+1}) = f(e_j) + \\mu(y_{j+1}), \\qquad f(e_1) = \\mu(y_1). \\] Esto garantiza que \\(\\operatorname{div} f=\\mu\\) sobre \\(y_1,\\ldots,y_{k-1}\\). Una vez terminado este algoritmo garantizamos que \\(\\operatorname{div} f=\\mu\\) en \\(V\\setminus \\{x_0\\}\\). Como última observación tenemos que la ecuación también debe cumplirse en \\(x_0\\) gracias a que \\(\\sum_{x\\in V} \\operatorname{div} f(x)=\\sum_{x\\in V} \\mu(x)=0\\). Notemos que si \\(x_0,\\ldots,x_k=x_0\\) es un dado ciclo del grafo, entonces si tomamos \\(f=1\\) en las aristas del ciclo y cero por fuera de estas, obtenemos una solución de \\(\\operatorname{div} f=0\\). De hecho, todas las soluciones homogéneas se obtienen por superposiciones de este ejemplo. El núcleo de la divergencia es un espacio vectorial generado por los ciclos independientes del grafo y su dimensión es un importante invariante topológico conocido como el primer número de Betti. Ejercicio 2.6 Calcula los flujos \\(f:E\\to \\mathbb R\\) tal que \\(\\operatorname{div} f=\\mu\\) para la función \\(\\mu\\) dada sobre los nodos del siguiente grafo. Solución Verificamos primero que la suma de los valores en los nodos se anula. Para calcular una solución particular tomamos el árbol generador con aristas \\(a\\), \\(b\\), \\(-e\\) y definimos así \\[ f(c)=f(d)=0, \\qquad f(a)=1, \\qquad f(e)=2, \\qquad f(b)=0 \\] el cual verifica fácilmente la ecuación de divergencia esperada en todos los nodos. Cualquier otra solución se obtiene como la superposición de la solución previa con las del sistema homogéneo \\[ \\begin{cases} f(a)+f(b)-f(e)=0,\\\\ -f(a)+f(c)=0,\\\\ -f(b)+f(d)=0,\\\\ -f(c)-f(d)+f(e)=0. \\end{cases} \\] Dos soluciones linealmente independientes se obtienen por ejemplo de los ciclos \\(a,c,e\\) y \\(b,d,e\\) respectivamente \\[ \\begin{aligned} &amp;f(a)=f(c)=f(e)=1,\\qquad f(b)=f(d)=0,\\\\ &amp;f(a)=f(c)=0, \\qquad f(b)=f(d)=f(e)=1. \\end{aligned} \\] Si usamos la reducción de Gauss-Jordan podemos verificar que esta es además una base de las soluciones homogéneas. 2.3 Integración por partes En esta sección denotamos \\(M=|V|&lt;\\infty\\) e identificamos a las funciones \\(u:V\\to \\mathbb R\\) con vectores de \\(\\mathbb R^M\\). Igualmente, \\(N=|E|&lt;\\infty\\) e identificamos a las funciones \\(i:E\\to \\mathbb R\\) con vectores de \\(\\mathbb R^N\\). Eventualmente también podríamos considerar funciones complejas. El gradiente \\(D:\\mathbb R^M\\to\\mathbb R^N\\) se representa así por la matriz \\((D_{e,x}) \\in \\mathbb R^{N\\times M}\\) tal que \\[ D_{e,x} = \\begin{cases} 1 \\text{ si } x=e_+,\\\\ -1 \\text{ si } x=e_-,\\\\ 0 \\text{ en cualquier otro caso}. \\end{cases} \\] Mientras que la divergencia \\(\\operatorname{div}:\\mathbb R^N\\to\\mathbb R^M\\) se representa por la matriz \\((\\operatorname{div}_{x,e}) \\in \\mathbb R^{M\\times N}\\) tal que \\[ \\operatorname{div}_{x,e} = \\begin{cases} -1 \\text{ si } e_+=x,\\\\ 1 \\text{ si } e_-=x,\\\\ 0 \\text{ en cualquier otro caso}. \\end{cases} \\] Descubrimos de esta forma que \\(D^T = -\\operatorname{div}\\) o equivalentemente la fórmula de integración por partes \\[ \\sum_{e\\in E} (fDu)(e) = f\\cdot Du = -u\\cdot \\operatorname{div} f = -\\sum_{x\\in V} (u\\operatorname{div} f)(x). \\] Ejercicio 2.7 Calcula las matrices asociadas con el gradiente y la divergencia para el siguiente grafo Solución \\[ D = \\begin{pmatrix} -1 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; -1 &amp; 0\\\\ -1 &amp; 0 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 1 &amp; -1 \\end{pmatrix} \\qquad \\operatorname{div} = -D^T = \\begin{pmatrix} 1 &amp; 0 &amp; -1 &amp; 1 &amp; 0\\\\ -1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 1 &amp; 0 &amp; -1\\\\ 0 &amp; 0 &amp; 0 &amp; -1 &amp; 1 \\end{pmatrix}. \\] Ejercicio 2.8 Demuestra la fórmula de integración por partes sobre un dominio \\(\\Omega \\subseteq V\\) \\[\\begin{equation} \\sum_{\\Omega} u\\operatorname{div}f = \\sum_{E} u^-fn_\\Omega - \\sum_{e_+\\in \\Omega} fDu. \\tag{2.2} \\end{equation}\\] En particular, si \\(u=1\\) recuperamos la fórmula de la divergencia (2.1). Solución Basta con usar que \\(Dv\\cdot f = - v\\cdot \\operatorname{div} f\\) para \\(v := u 1_{\\Omega}\\). Margen de cálculo: Integración por partes La fórmula de integración por partes nos dice que dado un subconjunto \\(\\Omega \\subset\\mathbb R^n\\) con frontera localmente de clase \\(C^1\\) a trozos, un campo vectorial \\(v\\in C^1(\\overline{\\Omega}\\to\\mathbb R^n)\\), y un campo escalar \\(u\\in C^1(\\overline{\\Omega}\\to\\mathbb R^n)\\) entonces \\[ \\int_\\Omega u \\operatorname{div} v = \\int_{\\partial \\Omega} u v\\cdot n - \\int_\\Omega Du\\cdot v \\] donde \\(n\\) es el vector normal exterior a \\(\\Omega\\). 2.3.1 Descomposición de Helmholtz Al igual que antes sean \\(M=|V|\\) y \\(N=|E|\\). La relación \\(D^T=-\\operatorname{div}\\) nos permite dar la descomposición ortogonal \\[ \\mathbb R^N = D(\\mathbb R^M) + \\ker(\\operatorname{div}). \\] también conocida como la descomposición de Helmholtz. Es decir que cualquier \\(f:E\\to\\mathbb R\\) puede escribirse de forma única3 como \\[ f = Du + g \\] tal que \\[ \\operatorname{div} j = 0, \\] y como corolario \\(Du \\perp j\\). En términos físicos, cualquier flujo se descompone en una parte que preserva la masa (\\(j\\)) y en un flujo gradiente (\\(Du\\)). Margen de álgebra lineal: El teorema fundamental de álgebra lineal Dado \\(A:\\mathbb R^M\\to \\mathbb R^N\\) se tiene que \\[ A(\\mathbb R^M)^\\perp = \\ker(A^T). \\] Si \\(x \\perp A(\\mathbb R^M)\\) entonces \\(0 = x\\cdot AA^Tx = \\|A^T x\\|^2\\), lo cual implica \\(A^Tx=0\\). Por otro lado si \\(A^Tx=0\\) entonces para \\(y\\in \\mathbb R^M\\) arbitrario \\(x\\cdot Ay = A^Tx\\cdot y=0\\). Ejercicio 2.9 Calcula la descomposición de Helmholtz para el siguiente flujo Solución Sea \\(f:E\\to \\mathbb R\\) los valores que se muestran en la gráfica. Buscamos calcular \\(u:V\\to \\mathbb R\\) y \\(j:E\\to \\mathbb R\\) tales que \\(f=Du+j\\) y \\(\\operatorname{div}j=0\\). Si tomamos así la divergencia en la expresión \\(f=Du+j\\) encontramos que \\(u\\) satisface \\[ \\begin{cases} -2u(A)+u(B)+u(C)=3,\\\\ u(A)-3u(B)+u(C)+u(D)=4,\\\\ u(A)+u(B)-3u(C)+u(D)=-7,\\\\ u(B)+u(C)-2u(D)=0. \\end{cases} \\] Las soluciones homogéneas del sistema son los potenciales constantes4. Ajustando esta constante de forma que \\(u(A)=0\\) obtenemos un sistema que podemos resolver numéricamente import numpy as np A = np.array([[ 1, 1, 0], [-3, 1, 1], [ 1,-3, 1]]) B = np.array([3, 4, -7]) X = np.linalg.inv(A).dot(B) Du = [X[0],X[1]-X[0],-X[1],X[2]-X[1],X[0]-X[2]] f = np.array([1,5,-2,0,0]) j = f-Du print(&quot;[Du(AB), Du(BC), Du(CA), Du(CD), Du(DB)] = {}.&quot;.format(Du)) ## [Du(AB), Du(BC), Du(CA), Du(CD), Du(DB)] = [0.125, 2.75, -2.875, -1.375, -1.375]. print(&quot;[j(AB), j(BC), j(CA), j(CD), j(DB)] = {}.&quot;.format(j)) ## [j(AB), j(BC), j(CA), j(CD), j(DB)] = [0.875 2.25 0.875 1.375 1.375]. 2.4 Laplaciano El Laplaciano es un operador diferencial que se construye aplicando sucesivamente el gradiente y la divergencia. Es decir que mide la producción de masa del gradiente. Además, luego de una manipulación algebraica, observamos que es proporcional a la diferencia entre el promedio en los vértices adyacentes y el valor en el centro. Definición 2.5 Dado \\(u: V \\to \\mathbb R\\), el Laplaciano \\(\\Delta u: V \\to \\mathbb R\\) se define tal que \\[ \\Delta u(v) = \\operatorname{div}(D u)(v) = \\sum_{w \\sim v} (u(w)-u(v)). \\] donde \\(w \\sim v\\) si existe una arista que une a \\(v\\) y \\(w\\) en cualquier orientación. A pesar de que tanto el gradiente como la divergencia requieren que el grafo tenga una orientación, el Laplaciano está bien definido en grafos no dirigidos. Cuando \\(u: V \\to \\mathbb R\\) es un potencial tal que \\(\\Delta u=0\\) en \\(\\Omega \\subseteq V\\), decimos que \\(u\\) es una función armónica sobre \\(\\Omega\\). Ejemplo 2.6 Considera una red eléctrica con resistencias de un Ohm (\\(R(e)=1\\)) la cual modelamos como una grafo dirigido de forma arbitraria. Una batería de un voltio entre dos nodos \\(v_+,v_-\\in V\\) genera un potencial eléctrico \\(u:V\\to \\mathbb R\\) que se puede determinar a partir de la ley de Ohm y la ley de Kirchhoff. Según la ley de Ohm tenemos que la corriente se calcula según \\[ i=Du. \\] Según la ley de Kirchhoff tenemos que fuera de los nodos donde se conecta la bateria, la corriente se conserva, es decir \\[ 0=\\operatorname{div}i = \\Delta u \\text{ en } V\\setminus\\{v_\\pm\\} \\] Junto con las condiciones de borde en los nodos donde se conecta la batería \\[ \\qquad u(v_+) = 1, \\qquad u(v_-) = 0, \\] obtenemos un sistema de ecuaciones lineales con igual número de ecuaciones que de incógnitas. Ejercicio 2.10 Calcula el potencial eléctrico que se genera en un cubo de resistencias de un Ohm, cuando se conecta una batería de un voltio entre dos nodos opuestos del cubo Solución Asumamos sin pérdida de gneralidad que se conecta la bateria de los nodos \\(A\\) a \\(D\\) tal que \\(v(A)=1\\) y \\(v(D)=0\\). Tenemos un sistema de ecuaciones lineales de dimensiones 6 por 6. De existir una única solución5 observamos que por simetría se debe cumplir que \\(v(B)=v(F)=v(H)=\\alpha\\) (los nodos adyacentes a \\(A\\)) y \\(v(C)=v(E)=v(G)=\\beta\\) (los nodos adyacentes a \\(E\\)). Esto reduce el sistema a uno de 2 por 2 \\[ \\begin{cases} -9\\alpha+6\\beta = -3,\\\\ 6\\alpha -9\\beta = 0 \\end{cases} \\qquad\\Rightarrow\\qquad \\alpha = \\frac{3}{5}, \\qquad \\beta = \\frac{2}{5}. \\] Ejercicio 2.11 Calcula la matriz asociada al Laplaciano para el grafo a continuación Solución \\[ \\Delta = \\operatorname{div} D = \\begin{pmatrix} 1 &amp; 0 &amp; -1 &amp; 1 &amp; 0\\\\ -1 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 1 &amp; 0 &amp; -1\\\\ 0 &amp; 0 &amp; 0 &amp; -1 &amp; 1 \\end{pmatrix}\\begin{pmatrix} -1 &amp; 1 &amp; 0 &amp; 0\\\\ 0 &amp; -1 &amp; 1 &amp; 0\\\\ 1 &amp; 0 &amp; -1 &amp; 0\\\\ -1 &amp; 0 &amp; 0 &amp; 1\\\\ 0 &amp; 0 &amp; 1 &amp; -1 \\end{pmatrix} = \\begin{pmatrix} -3 &amp; 1 &amp; 1 &amp; 1\\\\ 1 &amp; -2 &amp; 1 &amp; 0\\\\ 1 &amp; 1&amp; -3 &amp; 1\\\\ 1 &amp; 0 &amp; 1 &amp; -2 \\end{pmatrix} \\] Ejercicio 2.12 Da un análogo discreto para la fórmula de Green \\[ \\int_\\Omega (u_1\\Delta u_2 - u_2\\Delta u_1) = \\int_{\\partial\\Omega} (u_1Du_2 - u_2 Du_1)\\cdot n \\] Solución De la fórmula de integración por partes (2.2) \\[ \\sum_\\Omega u_i \\Delta u_j = \\sum_{E} u_i^- Du_j n_\\Omega - \\sum_{e_+\\in \\Omega} Du_iDu_j \\] Por lo tanto al tomar la resta se cancelan el segundo término a la deracha quedando así \\[ \\sum_\\Omega (u_1 \\Delta u_2-u_2 \\Delta u_1) = \\sum_{E} (u_1^- Du_2 - u_2^- Du_1)n_\\Omega. \\] En general podemos añadir una operación intermedia entre el gradiente y la divergencia. Esto genera operadores con características similares al Laplaciano. Ejemplo 2.7 Considera ahora una red eléctrica con resistencias variables. La ley de Ohm consiste en tomar el gradiente del potencial y luego dividir por las resistencias para obtener la corriente. Al recíproco de la resistencia también se le conoce como la capacitancia y puede ser más conveniente de usar en este ejemplo. En este caso las ecuaciones de balance para el potencial eléctrico tienen la forma \\[ \\operatorname{div} (CDu) = 0 \\qquad C = 1/R : \\text{Capacitancia} \\] (fuera de los nodos donde se conecta la batería). En el caso particular de las resistencias dadas en la siguiente gráfica, obtenemos el operador lineal asociado a la siguiente matriz import numpy as np # Gradiente D = np.array([[-1, 1, 0, 0], [0, -1, 1, 0], [1, 0, -1, 0], [-1, 0, 0, 1], [0, 0, 1, -1]]) # Capacitancia (C=1/R) C = np.array([[1, 0, 0, 0, 0], [0, 1/4, 0, 0, 0], [0, 0, 1/2, 0, 0], [0, 0, 0, 1/5, 0], [0, 0, 0, 0, 1/3]]) # Operador L = div(CD) L = -np.matmul(D.T,np.matmul(C,D)) print(L) ## [[-1.7 1. 0.5 0.2 ] ## [ 1. -1.25 0.25 -0. ] ## [ 0.5 0.25 -1.08333333 0.33333333] ## [ 0.2 -0. 0.33333333 -0.53333333]] Ejemplo 2.8 Las ecuaciones de balance en los entramados se implementan en tres pasos: Se toman las posiciones relativas entre nodos adyacentes, es decir el gradiente de las posiciones \\(q:V\\to\\mathbb R^2\\). Se forman las tensiones a partir de las posiciones relativas y los multiplicadores \\(\\lambda:E\\to \\mathbb R\\). Se propone el balance de fuerzas en términos de la divergencia de la tensión. En síntesis se obtiene que en los nodos libres \\[ \\operatorname{div} (\\lambda D q) = mge_2 \\] A diferencia de los problemas de redes eléctricas, tanto \\(q\\) como \\(\\lambda\\) son variables por ser determinadas lo cual hace que el problema sea no-lineal en dichas incógnitas. es decir que cualquier ciclo puede ser deformado continuamente a un punto. Por ejemplo, si \\(n=2\\) dice que \\(\\Omega\\) no tiene hoyos.↩︎ Dado \\(f:E\\to \\mathbb R\\), el potencial \\(u\\) no es único pero su gradiente \\(Du\\) sí.↩︎ Esto puede verificarse de la reducción de Gauss-Jordan en este caso, y además será demostrado con mayor generalidad.↩︎ Una vez más, esto puede chequearse a mano o con una herramienta numérica.↩︎ "],["dinámica.html", "Capítulo 3 Dinámica 3.1 Transporte 3.2 Difusión 3.3 Oscilación", " Capítulo 3 Dinámica 3.1 Transporte Consideremos un grafo dirigido \\(G=(V,E)\\) y una familia de densidades \\(u(x,t)\\) que toma valores reales para cada vértice \\(x\\in V\\) en tiempo \\(t\\in\\mathbb R\\). Decimos que un flujo \\(f(e,t)\\) transporta a \\(u\\) si en cada instante salen \\(f(e,t)\\) unidades de masa de \\(e_-\\) hacia \\(e_+\\) por la arista \\(e\\). Es decir que sobre cada \\(x\\in V\\) se tiene que \\[ \\partial_t u(x,t) = \\sum_{e_+=x} f(e,t) - \\sum_{e_-=x} f(e,t) = -\\operatorname{div} f(x,t). \\] Observamos que si en un dado nodo \\(x\\in V\\) se tiene que \\(\\operatorname{div} f(x)&gt;0\\) entonces \\(u\\) es decreciente. Esto quiere decir que el flujo hace que la densidad se esparza o diverja sobre dicho nodo. De igual forma, si \\(\\operatorname{div} f(x)&lt;0\\), \\(u\\) es creciente y el flujo hace que la densidad en cambio converga en dicho nodo. Ejemplo 3.1 Consideremos una densidad \\(u:V\\times \\mathbb R\\to \\mathbb R\\) transportada por un flujo \\(f := \\mu u^-\\) donde \\(\\mu:E\\to \\mathbb R\\) son tazas de movilidad dadas sobre las aristas en el grafo a continuación y recordemos que \\(u^-(e)=u(e_-)\\) Comenzando de la distribución de densidades \\[ u(0) = (1,0,0,0) \\] integramos numericamente las cuatro ecuaciones dadas por \\[ \\partial_t u = -\\operatorname{div}(\\mu u^-) \\qquad\\Leftrightarrow \\qquad \\begin{cases} u(1)&#39; = -3u(1)+3u(3),\\\\ u(2)&#39; = u(1) - u(2),\\\\ u(3)&#39; = u(2) - 3u(3) + 2u(4),\\\\ u(4)&#39; = 2u(1)-2u(4). \\end{cases} \\] y obtenemos lo siguiente: import numpy as np import matplotlib.pyplot as plt import scipy as sp from scipy.integrate import odeint A = np.array([[-3, 0, 3, 0], [1, -1, 0, 0], [0, 1, -3, 2], [2, 0, 0, -2]]) def dudt(u,t): return np.matmul(A,u) u0 = np.array([1,0,0,0]) t = np.linspace(0,2,1000) sol = odeint(dudt,u0,t) plt.plot(t,sol[:,0], label=&#39;1&#39;) plt.plot(t,sol[:,1], label=&#39;2&#39;) plt.plot(t,sol[:,2], label=&#39;3&#39;) plt.plot(t,sol[:,3], label=&#39;4&#39;) plt.legend() plt.show() Adicionalmente podemos considerar modelos donde además del fenómeno de transporte, una o más densidades tienen distintas reacciones en cada uno de los nodos. Ejemplo 3.2 Las funciones \\(S,I:V\\to \\mathbb R\\) representan poblaciones de individuos susceptibles e infectados para una dada epidemia modelada geográficamente sobre un grafo dirigido \\(G=(V,E)\\). Cada una de estas poblaciones se mueve sobre las aristas por flujos dados por \\[ f_S := \\mu_S S^-, \\qquad f_I := \\mu_I I^-. \\] donde \\(\\mu_S,\\mu_I: E\\to \\mathbb R\\) son tazas de movilidad sobre las aristas. La dinámica de la epidemia en cada nodo está dada por las tazas de transmisión (\\(\\beta\\)) y recuperación (\\(\\gamma\\)). En específico planteamos el modelo de \\(2|V|\\) ecuaciones de primer orden no-lineales \\[ \\partial_t S = -\\beta SI + \\operatorname{div}(\\mu_S S^-), \\qquad \\partial_t I = \\beta SI - \\gamma I + \\operatorname{div}(\\mu_I I^-),\\\\ \\] Ejercicio 3.1 Demuestra que el total de la población susceptible o infectada es una función decreciente. Solución \\[ \\partial_t \\sum_{V} (S+I) = \\sum_{V} (-\\gamma I + \\operatorname{div} f_S+\\operatorname{div}f_I) = - \\gamma \\sum_{V} I \\leq 0. \\] Ejercicio 3.2 Considera una epidemia dada en la siguiente red con los parámetros dados. En las aristas se muestran ciertas tasas de movilidad, para los susceptibles estas deben multiplicarse por \\(10^{-2}\\) y para los infectados por \\(10^{-4}\\). Implementa numéricamente y grafica las soluciones en el intervalo \\([0,160]\\) con condiciones iniciales \\[ S(0) = (1,1,1,1), \\qquad I(0) = (0, 10^{-6},0,0). \\] Solución import numpy as np import matplotlib.pyplot as plt import scipy as sp from scipy.integrate import odeint beta = 0.5 gamma = 0.3 L = np.array([[-5, 1, 2, 1], [2, -3, 1, 0], [1, 2, -4, 2], [2, 0, 1, -3]]) def dSIdt(SI,t): S = SI[:4] I = SI[4:] dS = -beta*S*I + 0.01*np.matmul(L,S) dI = beta*S*I - gamma*I + 0.0001*np.matmul(L,I) return np.concatenate((dS,dI)) S0 = np.array([1,1,1,1]) I0 = np.array([0,0.00000001,0,0]) SI0 = np.concatenate((S0,I0)) t = np.linspace(0,160,1000) sol = odeint(dSIdt,SI0,t) fig, ax = plt.subplots(2,2,figsize=(10,5)) ax[0,0].plot(t,sol[:,0], label=&#39;S1&#39;) ax[0,0].plot(t,sol[:,4], label=&#39;I1&#39;) ax[0,0].legend() ax[1,0].plot(t,sol[:,1], label=&#39;S2&#39;) ax[1,0].plot(t,sol[:,5], label=&#39;I2&#39;) ax[1,0].legend() ax[0,1].plot(t,sol[:,2], label=&#39;S3&#39;) ax[0,1].plot(t,sol[:,6], label=&#39;I3&#39;) ax[0,1].legend() ax[1,1].plot(t,sol[:,3], label=&#39;S4&#39;) ax[1,1].plot(t,sol[:,7], label=&#39;I4&#39;) ax[1,1].legend() 3.2 Difusión Así como vimos en los ejemplos anteriores donde el flujo era proporcional a \\(u^-\\), en general puede darse el caso de que \\(f\\) esté determinada por alguna otra función de \\(u\\), esto se conoce como una ley constitutiva. Un caso muy común es que \\(f\\) sea proporcional a \\(-Du\\), en el cual obtenemos un modelo de difusión. Ejemplo 3.3 Sea \\(G=(V,E)\\) un grafo que modela una red de habitaciones en renta y \\(u:V\\times \\mathbb R\\to\\mathbb R\\) la población que vive en dicha red. Asumiendo la ley de oferta y demanda, el precio de renta \\(p=p(x,t)\\) de una habitación \\(x\\) en el instante \\(t\\) debe ser proporcional a la demanda, la cual podemos considerar en nuestro caso proporcional a la población que habita dicho nodo, digamos por ejemplo que \\(p = k_1u\\). La población busca moverse entre nodos adyacentes si percibe que el precio le es favorable, por ejemplo \\(f=-k_2Dp\\). Llegamos así a la ecuación \\[ \\partial_t u = -\\operatorname{div} f = \\operatorname{div}(k_2Dp) = \\operatorname{div}(aDu), \\qquad a := k_1k_2. \\] El problema \\(\\partial_t u = \\operatorname{div}(aDu)\\), también conocido como la ecuación de calor o difusión, representa un sistema de EDOs lineales y de primer orden con tantas ecuaciones e incógnitas como la cardinalidad de \\(V\\). Ejercicio 3.3 Considera una difusión de la forma \\(\\partial_t u = \\Delta u\\) sobre el siguiente grafo. Calcula \\(u\\) para todo tiempo dadas las condiciones iniciales ilustradas en la figura. ¿Converge la solución a algún punto fijo? Solución El sistema de 4 EDOs se presenta como \\[ \\frac{d}{dt}\\begin{pmatrix} u(a)\\\\ u(b)\\\\ u(c)\\\\ u(d) \\end{pmatrix} = \\begin{pmatrix} -3 &amp; 1 &amp; 1 &amp; 1\\\\ 1 &amp; -2 &amp; 1 &amp; 0\\\\ 1 &amp; 1 &amp; -3 &amp; 1\\\\ 1 &amp; 0 &amp; 1 &amp; -2 \\end{pmatrix}\\begin{pmatrix} u(a)\\\\ u(b)\\\\ u(c)\\\\ u(d) \\end{pmatrix} \\] Dada que la condición inicial es \\((1,0,0,0)^T\\) buscamos la primera columna de la matriz exponencial. El siguiente resultado se obtuvo con la ayuda de sympy, una librería de cálculo simbólico de python from sympy import * t = Symbol(&#39;t&#39;) mt = Matrix([[-3, 1, 1, 1], [1, -2, 1, 0], [1, 1, -3, 1], [1, 0, 1, -2]]) * t mexp = mt.exp() print(&#39;$$&#39; + latex(mexp) + &#39;$$&#39;) \\[\\left[\\begin{matrix}\\frac{1}{4} + \\frac{3 e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4}\\\\\\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} + \\frac{e^{- 2 t}}{2} + \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 2 t}}{2} + \\frac{e^{- 4 t}}{4}\\\\\\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} + \\frac{3 e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4}\\\\\\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 2 t}}{2} + \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} - \\frac{e^{- 4 t}}{4} &amp; \\frac{1}{4} + \\frac{e^{- 2 t}}{2} + \\frac{e^{- 4 t}}{4}\\end{matrix}\\right]\\] Observamos que cuando \\(t\\to\\infty\\) la solución converge exponencialemente al vector \\((1/4,1/4,1/4,1/4)^T\\). De hecho esto sucede para cualquier condición incial. Ejercicio 3.4 Sea \\(G=(V,E)\\) un grafo lineal con 100 vértices \\[ V=\\{1,2,\\ldots,100\\}, \\qquad E = \\{(1,2),(2,3),\\ldots,(99,100)\\}. \\] Sea \\(u\\) solución de la ecuación de calor \\(\\partial_t u=\\Delta u\\) en \\(G\\) con condición inicial \\[ u(0) = e_{50} = (0,\\ldots,0,1,0,\\ldots,0). \\] Calcula el primer \\(t&gt;0\\) tal que \\(u(50,t)\\leq 0.1\\). Solución En este caso la dificultad está en cómo implementar el Laplaciano y encontrar el primer índice donde la solución baje de \\(0.1\\). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import odeint Delta = -2*np.eye(100)+np.eye(100,k=1)+np.eye(100,k=-1) Delta[0,0] = -1 Delta[99,99] = -1 def dudt(u,t): return np.matmul(Delta,u) u0 = np.zeros(100) u0[49] = 1 t = np.linspace(0,20,1000) sol = odeint(dudt,u0,t) index = np.where(sol[:,49]&lt;0.1)[0][0] plt.plot(t,sol[:,49]) plt.plot(t[index],sol[index,49],&#39;ro&#39;,label=&quot;({:.2f},{:.2f})&quot;.format(t[index],sol[index,49])) plt.legend() plt.title(&quot;u(50,t)&quot;) plt.show() 3.3 Oscilación El sistema de EDOs lineales y de segundo orden dado por \\[ \\partial_t^2 u = \\operatorname{div}(aDu) \\] también es común en distintos modelos. Esta se conoce como la ecuación de onda. Ejemplo 3.4 Un grafo \\(G=(V,E)\\) modela las conexiones en un sistema de masas \\(m:V\\to (0,\\infty)\\) unidas por resortes con constantes \\(k:E\\to[0,\\infty)\\). Sea \\(q:V\\to \\mathbb R^n\\) los desplazamientos de las masas a partir de una configuración dada de equilibrio. A partir de la ley de Hooke planteamos el sistema \\(n\\times|V|\\) ecuaciones e incógnitas, \\[ m\\partial_t^2 q = \\operatorname{div}(kDq). \\] Recordemos que cualquier sistema de segundo orden puede ser llevado a un sistema de primer orden tomando a las velocidades como incógnitas del sistema. Por ejemplo, \\[ \\partial_t^2 u = \\operatorname{div}(aDu) \\qquad \\Leftrightarrow\\qquad \\begin{cases} \\partial_t u = v,\\\\ \\partial_t v = \\operatorname{div}(aDu). \\end{cases} \\] Ejemplo 3.5 El grafo \\(G=(V,E)\\) vuelve a modelar una red de habitaciones en renta, \\(u:V\\times \\mathbb R\\to\\mathbb R\\) la población que vive en dicha red y \\(p:V\\times \\mathbb R\\to\\mathbb R\\) los precios. Una vez más asumimos que la población se mueve según el flujo \\(f = -Dp\\). Por otro lado los precios se modifican gradualmente dependiendo de la demanda en relación a los nodos adyacentes. Esto último puede ser reflejado por ejemplo en la ecuación \\(\\partial_t p = -\\Delta u\\), es decir que el precio disminuye si el promedio de la población vecina es mayor la población en el nodo en consideración, con la intención de atraerla. En resumen obtenemos el sistema de ecuaciones \\[ \\partial_t u = \\Delta p, \\qquad \\partial_t p = -\\Delta u. \\] Estas implican las ecuaciones de onda desacopladas para el bilaplaciano \\[ \\partial_t^2 u = -\\Delta^2 u, \\qquad \\partial_t^2 p = -\\Delta^2p. \\] Ejercicio 3.5 Considera una oscilación de la forma \\(\\partial_t^2 u = -\\Delta^2 u\\) sobre el siguiente grafo. Calcula \\(u\\) para todo tiempo dadas las condiciones iniciales ilustradas en la figura, partiendo del reposo. Grafica la solución en el intervalo \\([0,6]\\). Solución El sistema de 4 EDOs se presenta como \\[ \\frac{d}{dt}\\begin{pmatrix} u(a)\\\\ u(b)\\\\ u(c)\\\\ u(d)\\\\ u&#39;(a)\\\\ u&#39;(b)\\\\ u&#39;(c)\\\\ u&#39;(d) \\end{pmatrix} = \\begin{pmatrix} 0_4 &amp; I_4\\\\ -\\Delta^2 &amp; 0_4 \\end{pmatrix}\\begin{pmatrix} u(a)\\\\ u(b)\\\\ u(c)\\\\ u(d)\\\\ u&#39;(a)\\\\ u&#39;(b)\\\\ u&#39;(c)\\\\ u&#39;(d) \\end{pmatrix}, \\qquad \\Delta = \\begin{pmatrix} -3 &amp; 1 &amp; 1 &amp; 1\\\\ 1 &amp; -2 &amp; 1 &amp; 0\\\\ 1 &amp; 1 &amp; -3 &amp; 1\\\\ 1 &amp; 0 &amp; 1 &amp; -2 \\end{pmatrix} \\] Para calcular la solución analítica usamos el paquete simbólico de python. import numpy as np import matplotlib.pyplot as plt import sympy as smp from sympy.plotting import plot Delta = smp.Matrix([[-3,1,1,1], [1,-2,1,0], [1,1,-3,1], [1,0,1,-2]]) t = smp.symbols(&#39;t&#39;,real=&#39;True&#39;) B = smp.Matrix(smp.BlockMatrix([[smp.ZeroMatrix(4,4),smp.Identity(4)], [-Delta*Delta,smp.ZeroMatrix(4,4)]]))*t eB = smp.re(B.exp()) y0 = smp.Matrix([0,1,2,3,0,0,0,0]) y_s = eB*y0 print(&#39;$$&#39; + smp.latex(y_s[:4]) + &#39;$$&#39;) \\[\\left[ \\frac{3}{2} - \\frac{3 \\cos{\\left(4 t \\right)}}{2}, \\ - \\cos{\\left(2 t \\right)} + \\frac{\\cos{\\left(4 t \\right)}}{2} + \\frac{3}{2}, \\ \\frac{\\cos{\\left(4 t \\right)}}{2} + \\frac{3}{2}, \\ \\cos{\\left(2 t \\right)} + \\frac{\\cos{\\left(4 t \\right)}}{2} + \\frac{3}{2}\\right]\\] Las gráficas están dadas por eB_f = smp.lambdify(t,eB) t = np.linspace(0,6,600) y0 = np.array([0,1,2,3,0,0,0,0]) y = np.einsum(&#39;ijk,j-&gt;ik&#39;,eB_f(t),y0) plt.plot(t,y[0,:],label=&#39;a&#39;) plt.plot(t,y[1,:],label=&#39;b&#39;) plt.plot(t,y[2,:],label=&#39;c&#39;) plt.plot(t,y[3,:],label=&#39;d&#39;) plt.legend(loc=&#39;lower right&#39;) "],["implementación-del-entramado.html", "Capítulo 4 Implementación del entramado 4.1 Librerías y datos 4.2 Ecuación diferencial 4.3 Integración y graficación", " Capítulo 4 Implementación del entramado En esta sección veremos como poner en práctica los conceptos aprendidos para modelar una red cuadrada sujetada por sus cuatro esquinas. Recordemos que a pesar de que podemos dar una forma explícita de las ecuaciones que se deben resolver, el método de Newton parece ser muy sensible a las condiciones iniciales, por lo que hay que ingeniarse una forma alternativa. La idea que tenemos en mente es proponer que las conexiones entre nodos elásticas. Con esto proponemos un modelo elástico que gracias a un término de viscosidad podemos llevar al reposo. Con estas configuraciones terminales podemos luego ir haciendo la dureza (stiffness) de los resortes cada vez más y más grande, aproximando así la configuración de equilibrio cuando las barras son rígidas. 4.1 Librerías y datos Para fijar ideas proponemos una red con \\(N\\) por \\(N\\) nodos de masa \\(m&gt;0\\) como la ilustrada a continuación. La esquinas serán colgadas en los puntos \\((0,0,0)\\), \\((1,0,0)\\), \\((1,1,0)\\), y \\((0,1,0)\\). Entre cada par de nodos adyacentes se ubica un resorte cuya longitud natural es \\(l &gt; 1/(N-1)\\), dureza \\(k\\gg 1\\), y amortiguación \\(\\gamma &gt; 0\\). Es decir que si dos nodos adyacentes están a distancia \\(d\\), la magnitud de la fuerza que ejerce el resorte entre ellos es \\(k|d-l|\\). Esta fuerza es paralela a la línea que contiene a estos nodos y la dirección (o el signo) dependen de como se compare \\(d\\) respecto de \\(l\\): Para \\(d&gt;l\\) el resorte atrae a los nodos entre si, y para \\(d&lt;l\\) el resorte los repele. import numpy as np from numpy import linalg as la import matplotlib.pyplot as plt import scipy as sp import scipy.sparse as sps from scipy.integrate import odeint N = 10 # Longitud de la red m = 0.1 # Masa de los nodos gamma = 1 # Coeficiente de amortiguación k = 100 # Coeficiente de dureza l = 1.1/(N-1) # Longitud natural del resorte fijos = [0, N-1, N**2-N, N**2-1] # Esquinas fijas # Listas para enumerar las aristas de la red # Aristas verticales ini_v = list(range(N**2-N)) fin_v = list(range(N,N**2)) # Aristas horizontales ini_h = list(range(N**2)) del ini_h[slice(N-1,N**2,N)] fin_h = list(range(1,N**2+1)) del fin_h[slice(N-1,N**2,N)] ini = ini_h + ini_v # Nodos de salida fin = fin_h + fin_v # Nodos de llegada Ne = len(ini) # Número de aristas 4.2 Ecuación diferencial La ecuación diferencial que buscamos modelar para la posición \\(p=(x,y,z)\\) de cada nodo está dada por las leyes de Newton: \\[ mp&#39;&#39; = \\text{gravedad} + \\text{tensión} + \\text{amortiguación} \\] De estos tres tréminos la gravedad y la tensión son fáciles de calcular. Respectivamente son \\(-mge_z\\) y \\(-\\gamma p&#39;\\). Asumiendo el sistema internacional de unidades tomamos \\(g = 9.8\\). La dificultad reside ahora en implementar el cálculo de las tensiones. Recordemos además que para poder resolver nuestra EDO usando la librería de integración numérica de Scipy (odeint) debemos transformar el sistema a uno de primer orden. Esto significa que las velocidades pasan a ser parte de las incógnitas. Codificamos en la curva \\(s=s(t)\\) las configuraciones de nuestro sistema de la siguiente forma \\[ s = (pos,vel) = ((x,y,z),(vx,vy,vz)) \\in (\\mathbb R^{N^2}\\times\\mathbb R^{N^2}\\times\\mathbb R^{N^2})\\times(\\mathbb R^{N^2}\\times\\mathbb R^{N^2}\\times\\mathbb R^{N^2}) \\] Dadas las posiciones \\(p_{ini}\\) y \\(p_{fin}\\) de dos nodos extremos sobre una arista dada tenemos que la tensión sobre dicha arista se calcula por \\[ T := k(d-l)\\theta, \\qquad d := |p_{fin}-p_{ini}|, \\qquad \\theta := \\frac{p_{fin}-p_{ini}}{d} \\] Esta es justamente la tensión que se ejerce sobre el nodo inicial de la arista, siendo la fuerza opuesta en el otro nodo gracias a la tercera ley de Newton. Un paso técnico a partir de acá consiste en transferir está informaición dada sobre las aristas a los nodos. Estas consideraciones teóricas quedan reflejadas en la siguiente función: def dsdt(s,t): pos = np.reshape(s[:3*N**2],(3,N**2)).T vel = np.reshape(s[3*N**2:],(3,N**2)).T pos_rel = pos[fin] - pos[ini] lon_rel = np.tile(la.norm(pos_rel,axis=1),(3,1)).T # d dir_rel = pos_rel/lon_rel # theta ten_esc = k*(lon_rel-l*np.ones((Ne,3))) # Magnitud de la tensión (signada) ten_ari = ten_esc*dir_rel # Tensión sobre el nodo inicial # Tensión total sobre cada nodo. Usamos una estructura de matrices ralas (sparse) para codificarlas eficientemente. data = np.concatenate((ten_ari.T.reshape(-1),-ten_ari.T.reshape(-1))) fila = 3*ini+3*fin colu = 2*(Ne*[0]+Ne*[1]+Ne*[2]) ten_nod = sps.coo_matrix((data, (fila, colu))).toarray() # Fuerzas y aceleración fue_gra = -9.8*m*np.tile(np.array([0,0,1]),(N**2,1)) # Gravedad visc = -gamma*vel # Amortiguación acel = (ten_nod + fue_gra + visc)/m # Aceleración acel[fijos,:] = [0,0,0] # Esquinas fijas return np.concatenate((s[3*N**2:],acel.T.reshape(-1))) 4.3 Integración y graficación Una vez modelada la ecuación diferencial ya podemos proceder a integrarla usando por ejemplo el comando odeint de la librería Scipy. Para ello necesitamos dar adicionalmente un intervalo de tiempo discreto y una condición inicial. px, py = np.meshgrid(np.linspace(0,1,N),np.linspace(0,1,N)) s0 = np.concatenate((px.reshape(-1), py.reshape(-1),np.zeros(N**2),np.zeros(3*N**2))) t = np.linspace(0,10,2000) sol = odeint(dsdt,s0,t) Visualización del último instante fig = plt.figure() ax = plt.axes(projection=&#39;3d&#39;) ax.axes.set_xlim3d(left=0, right=1); ax.axes.set_ylim3d(bottom=0, top=1); ax.axes.set_zlim3d(bottom=-1, top=0); ax.view_init(60, 80); sol_fin = sol[-1,:] pos = np.reshape(sol_fin[:3*N**2],(3,N**2)).T for i in range(N): ax.plot3D(pos[i*N:(i+1)*N,0], pos[i*N:(i+1)*N:,1], pos[i*N:(i+1)*N,2],&#39;bo-&#39;) ax.plot3D(pos[i:N**2:N,0], pos[i:N**2:N,1], pos[i:N**2:N,2],&#39;b-&#39;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
