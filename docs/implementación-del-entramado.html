<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Capítulo 4 Implementación del entramado | Métodos de matemáticas aplicadas</title>
  <meta name="description" content="<p>This is a minimal example of using the bookdown package to write a book.
The HTML output format for this example is bookdown::gitbook,
set in the _output.yml file.</p>" />
  <meta name="generator" content="bookdown 0.27 and GitBook 2.6.7" />

  <meta property="og:title" content="Capítulo 4 Implementación del entramado | Métodos de matemáticas aplicadas" />
  <meta property="og:type" content="book" />
  
  <meta property="og:description" content="<p>This is a minimal example of using the bookdown package to write a book.
The HTML output format for this example is bookdown::gitbook,
set in the _output.yml file.</p>" />
  <meta name="github-repo" content="rstudio/bookdown-demo" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Capítulo 4 Implementación del entramado | Métodos de matemáticas aplicadas" />
  
  <meta name="twitter:description" content="<p>This is a minimal example of using the bookdown package to write a book.
The HTML output format for this example is bookdown::gitbook,
set in the _output.yml file.</p>" />
  

<meta name="author" content="Héctor Andrés Chang-Lara" />


<meta name="date" content="2022-08-17" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="dinámica.html"/>

<script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />








<link href="libs/anchor-sections-1.1.0/anchor-sections.css" rel="stylesheet" />
<link href="libs/anchor-sections-1.1.0/anchor-sections-hash.css" rel="stylesheet" />
<script src="libs/anchor-sections-1.1.0/anchor-sections.js"></script>


<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Métodos de matemáticas aplicadas</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Prefacio</a></li>
<li class="chapter" data-level="1" data-path="entramados.html"><a href="entramados.html"><i class="fa fa-check"></i><b>1</b> Entramados</a></li>
<li class="chapter" data-level="2" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html"><i class="fa fa-check"></i><b>2</b> Cálculo discreto</a>
<ul>
<li class="chapter" data-level="2.1" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html#gradiente"><i class="fa fa-check"></i><b>2.1</b> Gradiente</a>
<ul>
<li class="chapter" data-level="2.1.1" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html#ley-de-ciclos"><i class="fa fa-check"></i><b>2.1.1</b> Ley de ciclos</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html#divergencia"><i class="fa fa-check"></i><b>2.2</b> Divergencia</a>
<ul>
<li class="chapter" data-level="2.2.1" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html#fórmula-de-la-divergencia"><i class="fa fa-check"></i><b>2.2.1</b> Fórmula de la divergencia</a></li>
<li class="chapter" data-level="2.2.2" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html#lema-de-poincaré-para-la-divergencia"><i class="fa fa-check"></i><b>2.2.2</b> Lema de Poincaré para la divergencia</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html#integración-por-partes"><i class="fa fa-check"></i><b>2.3</b> Integración por partes</a>
<ul>
<li class="chapter" data-level="2.3.1" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html#descomposición-de-helmholtz"><i class="fa fa-check"></i><b>2.3.1</b> Descomposición de Helmholtz</a></li>
</ul></li>
<li class="chapter" data-level="2.4" data-path="cálculo-discreto.html"><a href="cálculo-discreto.html#laplaciano"><i class="fa fa-check"></i><b>2.4</b> Laplaciano</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="dinámica.html"><a href="dinámica.html"><i class="fa fa-check"></i><b>3</b> Dinámica</a>
<ul>
<li class="chapter" data-level="3.1" data-path="dinámica.html"><a href="dinámica.html#transporte"><i class="fa fa-check"></i><b>3.1</b> Transporte</a></li>
<li class="chapter" data-level="3.2" data-path="dinámica.html"><a href="dinámica.html#difusión"><i class="fa fa-check"></i><b>3.2</b> Difusión</a></li>
<li class="chapter" data-level="3.3" data-path="dinámica.html"><a href="dinámica.html#oscilación"><i class="fa fa-check"></i><b>3.3</b> Oscilación</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="implementación-del-entramado.html"><a href="implementación-del-entramado.html"><i class="fa fa-check"></i><b>4</b> Implementación del entramado</a>
<ul>
<li class="chapter" data-level="4.1" data-path="implementación-del-entramado.html"><a href="implementación-del-entramado.html#librerías-y-datos"><i class="fa fa-check"></i><b>4.1</b> Librerías y datos</a></li>
<li class="chapter" data-level="4.2" data-path="implementación-del-entramado.html"><a href="implementación-del-entramado.html#ecuación-diferencial"><i class="fa fa-check"></i><b>4.2</b> Ecuación diferencial</a></li>
<li class="chapter" data-level="4.3" data-path="implementación-del-entramado.html"><a href="implementación-del-entramado.html#integración-y-graficación"><i class="fa fa-check"></i><b>4.3</b> Integración y graficación</a></li>
<li class="chapter" data-level="4.4" data-path="implementación-del-entramado.html"><a href="implementación-del-entramado.html#espectro-del-laplaciano"><i class="fa fa-check"></i><b>4.4</b> Espectro del Laplaciano</a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Métodos de matemáticas aplicadas</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="implementación-del-entramado" class="section level1 hasAnchor" number="4">
<h1><span class="header-section-number">Capítulo 4</span> Implementación del entramado<a href="implementación-del-entramado.html#implementación-del-entramado" class="anchor-section" aria-label="Anchor link to header"></a></h1>
<p>En esta sección veremos como poner en práctica los conceptos aprendidos para modelar una red cuadrada sujetada por sus cuatro esquinas. Recordemos que a pesar de que podemos dar una forma explícita de las ecuaciones que se deben resolver, el método de Newton parece ser muy sensible a las condiciones iniciales, por lo que hay que ingeniarse una forma alternativa.</p>
<p>La idea que tenemos en mente es proponer que las conexiones entre nodos elásticas. Con esto proponemos un modelo elástico que gracias a un término de viscosidad podemos llevar al reposo. Con estas configuraciones terminales podemos luego ir haciendo la dureza (stiffness) de los resortes cada vez más y más grande, aproximando así la configuración de equilibrio cuando las barras son rígidas.</p>
<div id="librerías-y-datos" class="section level2 hasAnchor" number="4.1">
<h2><span class="header-section-number">4.1</span> Librerías y datos<a href="implementación-del-entramado.html#librerías-y-datos" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Para fijar ideas proponemos una red con <span class="math inline">\(N\)</span> por <span class="math inline">\(N\)</span> nodos de masa <span class="math inline">\(m&gt;0\)</span> como la ilustrada a continuación. La esquinas serán colgadas en los puntos <span class="math inline">\((0,0,0)\)</span>, <span class="math inline">\((1,0,0)\)</span>, <span class="math inline">\((1,1,0)\)</span>, y <span class="math inline">\((0,1,0)\)</span>.</p>
<p><img src="red.png" style="width:70.0%" /></p>
<p>Entre cada par de nodos adyacentes se ubica un resorte cuya longitud natural es <span class="math inline">\(l &gt; 1/(N-1)\)</span>, dureza <span class="math inline">\(k\gg 1\)</span>, y amortiguación <span class="math inline">\(\gamma &gt; 0\)</span>. Es decir que si dos nodos adyacentes están a distancia <span class="math inline">\(d\)</span>, la magnitud de la fuerza que ejerce el resorte entre ellos es <span class="math inline">\(k|d-l|\)</span>. Esta fuerza es paralela a la línea que contiene a estos nodos y la dirección (o el signo) dependen de como se compare <span class="math inline">\(d\)</span> respecto de <span class="math inline">\(l\)</span>: Para <span class="math inline">\(d&gt;l\)</span> el resorte atrae a los nodos entre si, y para <span class="math inline">\(d&lt;l\)</span> el resorte los repele.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="implementación-del-entramado.html#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb14-2"><a href="implementación-del-entramado.html#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> numpy <span class="im">import</span> linalg <span class="im">as</span> la</span>
<span id="cb14-3"><a href="implementación-del-entramado.html#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb14-4"><a href="implementación-del-entramado.html#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy <span class="im">as</span> sp</span>
<span id="cb14-5"><a href="implementación-del-entramado.html#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.sparse <span class="im">as</span> sps</span>
<span id="cb14-6"><a href="implementación-del-entramado.html#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.integrate <span class="im">import</span> odeint</span>
<span id="cb14-7"><a href="implementación-del-entramado.html#cb14-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-8"><a href="implementación-del-entramado.html#cb14-8" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">10</span>        <span class="co"># Longitud de la red</span></span>
<span id="cb14-9"><a href="implementación-del-entramado.html#cb14-9" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="fl">0.1</span>       <span class="co"># Masa de los nodos</span></span>
<span id="cb14-10"><a href="implementación-del-entramado.html#cb14-10" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> <span class="dv">1</span>     <span class="co"># Coeficiente de amortiguación</span></span>
<span id="cb14-11"><a href="implementación-del-entramado.html#cb14-11" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">100</span>       <span class="co"># Coeficiente de dureza</span></span>
<span id="cb14-12"><a href="implementación-del-entramado.html#cb14-12" aria-hidden="true" tabindex="-1"></a>l <span class="op">=</span> <span class="fl">1.1</span><span class="op">/</span>(N<span class="op">-</span><span class="dv">1</span>) <span class="co"># Longitud natural del resorte</span></span>
<span id="cb14-13"><a href="implementación-del-entramado.html#cb14-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-14"><a href="implementación-del-entramado.html#cb14-14" aria-hidden="true" tabindex="-1"></a>fijos <span class="op">=</span> [<span class="dv">0</span>, N<span class="op">-</span><span class="dv">1</span>, N<span class="op">**</span><span class="dv">2</span><span class="op">-</span>N, N<span class="op">**</span><span class="dv">2</span><span class="op">-</span><span class="dv">1</span>] <span class="co"># Esquinas fijas</span></span>
<span id="cb14-15"><a href="implementación-del-entramado.html#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="implementación-del-entramado.html#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Listas para enumerar las aristas de la red</span></span>
<span id="cb14-17"><a href="implementación-del-entramado.html#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="implementación-del-entramado.html#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Aristas verticales</span></span>
<span id="cb14-19"><a href="implementación-del-entramado.html#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="implementación-del-entramado.html#cb14-20" aria-hidden="true" tabindex="-1"></a>ini_v <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(N<span class="op">**</span><span class="dv">2</span><span class="op">-</span>N))</span>
<span id="cb14-21"><a href="implementación-del-entramado.html#cb14-21" aria-hidden="true" tabindex="-1"></a>fin_v <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(N,N<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb14-22"><a href="implementación-del-entramado.html#cb14-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-23"><a href="implementación-del-entramado.html#cb14-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Aristas horizontales</span></span>
<span id="cb14-24"><a href="implementación-del-entramado.html#cb14-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-25"><a href="implementación-del-entramado.html#cb14-25" aria-hidden="true" tabindex="-1"></a>ini_h <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(N<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb14-26"><a href="implementación-del-entramado.html#cb14-26" aria-hidden="true" tabindex="-1"></a><span class="kw">del</span> ini_h[<span class="bu">slice</span>(N<span class="op">-</span><span class="dv">1</span>,N<span class="op">**</span><span class="dv">2</span>,N)]</span>
<span id="cb14-27"><a href="implementación-del-entramado.html#cb14-27" aria-hidden="true" tabindex="-1"></a>fin_h <span class="op">=</span> <span class="bu">list</span>(<span class="bu">range</span>(<span class="dv">1</span>,N<span class="op">**</span><span class="dv">2</span><span class="op">+</span><span class="dv">1</span>))</span>
<span id="cb14-28"><a href="implementación-del-entramado.html#cb14-28" aria-hidden="true" tabindex="-1"></a><span class="kw">del</span> fin_h[<span class="bu">slice</span>(N<span class="op">-</span><span class="dv">1</span>,N<span class="op">**</span><span class="dv">2</span>,N)]</span>
<span id="cb14-29"><a href="implementación-del-entramado.html#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="implementación-del-entramado.html#cb14-30" aria-hidden="true" tabindex="-1"></a>ini <span class="op">=</span> ini_h <span class="op">+</span> ini_v     <span class="co"># Nodos de salida</span></span>
<span id="cb14-31"><a href="implementación-del-entramado.html#cb14-31" aria-hidden="true" tabindex="-1"></a>fin <span class="op">=</span> fin_h <span class="op">+</span> fin_v     <span class="co"># Nodos de llegada</span></span>
<span id="cb14-32"><a href="implementación-del-entramado.html#cb14-32" aria-hidden="true" tabindex="-1"></a>Ne <span class="op">=</span> <span class="bu">len</span>(ini)           <span class="co"># Número de aristas</span></span></code></pre></div>
</div>
<div id="ecuación-diferencial" class="section level2 hasAnchor" number="4.2">
<h2><span class="header-section-number">4.2</span> Ecuación diferencial<a href="implementación-del-entramado.html#ecuación-diferencial" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>La ecuación diferencial que buscamos modelar para la posición <span class="math inline">\(p=(x,y,z)\)</span> de cada nodo está dada por las leyes de Newton:
<span class="math display">\[
mp&#39;&#39; = \text{gravedad} + \text{tensión} + \text{amortiguación}
\]</span></p>
<p>De estos tres tréminos la gravedad y la tensión son fáciles de calcular. Respectivamente son <span class="math inline">\(-mge_z\)</span> y <span class="math inline">\(-\gamma p&#39;\)</span>. Asumiendo el sistema internacional de unidades tomamos <span class="math inline">\(g = 9.8\)</span>. La dificultad reside ahora en implementar el cálculo de las tensiones.</p>
<p>Recordemos además que para poder resolver nuestra EDO usando la librería de integración numérica de Scipy (odeint) debemos transformar el sistema a uno de primer orden. Esto significa que las velocidades pasan a ser parte de las incógnitas. Codificamos en la curva <span class="math inline">\(s=s(t)\)</span> las configuraciones de nuestro sistema de la siguiente forma
<span class="math display">\[
s = (pos,vel) = ((x,y,z),(vx,vy,vz)) \in (\mathbb R^{N^2}\times\mathbb R^{N^2}\times\mathbb R^{N^2})\times(\mathbb R^{N^2}\times\mathbb R^{N^2}\times\mathbb R^{N^2})
\]</span>
Dadas las posiciones <span class="math inline">\(p_{ini}\)</span> y <span class="math inline">\(p_{fin}\)</span> de dos nodos extremos sobre una arista dada tenemos que la tensión sobre dicha arista se calcula por
<span class="math display">\[
T := k(d-l)\theta, \qquad d := |p_{fin}-p_{ini}|, \qquad \theta := \frac{p_{fin}-p_{ini}}{d}
\]</span>
Esta es justamente la tensión que se ejerce sobre el nodo inicial de la arista, siendo la fuerza opuesta en el otro nodo gracias a la tercera ley de Newton. Un paso técnico a partir de acá consiste en transferir está informaición dada sobre las aristas a los nodos.</p>
<p>Estas consideraciones teóricas quedan reflejadas en la siguiente función:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="implementación-del-entramado.html#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dsdt(s,t):</span>
<span id="cb15-2"><a href="implementación-del-entramado.html#cb15-2" aria-hidden="true" tabindex="-1"></a>  pos <span class="op">=</span> np.reshape(s[:<span class="dv">3</span><span class="op">*</span>N<span class="op">**</span><span class="dv">2</span>],(<span class="dv">3</span>,N<span class="op">**</span><span class="dv">2</span>)).T</span>
<span id="cb15-3"><a href="implementación-del-entramado.html#cb15-3" aria-hidden="true" tabindex="-1"></a>  vel <span class="op">=</span> np.reshape(s[<span class="dv">3</span><span class="op">*</span>N<span class="op">**</span><span class="dv">2</span>:],(<span class="dv">3</span>,N<span class="op">**</span><span class="dv">2</span>)).T</span>
<span id="cb15-4"><a href="implementación-del-entramado.html#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="implementación-del-entramado.html#cb15-5" aria-hidden="true" tabindex="-1"></a>  pos_rel <span class="op">=</span> pos[fin] <span class="op">-</span> pos[ini]</span>
<span id="cb15-6"><a href="implementación-del-entramado.html#cb15-6" aria-hidden="true" tabindex="-1"></a>  lon_rel <span class="op">=</span> np.tile(la.norm(pos_rel,axis<span class="op">=</span><span class="dv">1</span>),(<span class="dv">3</span>,<span class="dv">1</span>)).T   <span class="co"># d</span></span>
<span id="cb15-7"><a href="implementación-del-entramado.html#cb15-7" aria-hidden="true" tabindex="-1"></a>  dir_rel <span class="op">=</span> pos_rel<span class="op">/</span>lon_rel                            <span class="co"># theta</span></span>
<span id="cb15-8"><a href="implementación-del-entramado.html#cb15-8" aria-hidden="true" tabindex="-1"></a>  ten_esc <span class="op">=</span> k<span class="op">*</span>(lon_rel<span class="op">-</span>l<span class="op">*</span>np.ones((Ne,<span class="dv">3</span>)))              <span class="co"># Magnitud de la tensión (signada)</span></span>
<span id="cb15-9"><a href="implementación-del-entramado.html#cb15-9" aria-hidden="true" tabindex="-1"></a>  ten_ari <span class="op">=</span> ten_esc<span class="op">*</span>dir_rel                            <span class="co"># Tensión sobre el nodo inicial</span></span>
<span id="cb15-10"><a href="implementación-del-entramado.html#cb15-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-11"><a href="implementación-del-entramado.html#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Tensión total sobre cada nodo. Usamos una estructura de matrices ralas (sparse) para codificarlas eficientemente.</span></span>
<span id="cb15-12"><a href="implementación-del-entramado.html#cb15-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-13"><a href="implementación-del-entramado.html#cb15-13" aria-hidden="true" tabindex="-1"></a>  data <span class="op">=</span> np.concatenate((ten_ari.T.reshape(<span class="op">-</span><span class="dv">1</span>),<span class="op">-</span>ten_ari.T.reshape(<span class="op">-</span><span class="dv">1</span>)))</span>
<span id="cb15-14"><a href="implementación-del-entramado.html#cb15-14" aria-hidden="true" tabindex="-1"></a>  fila <span class="op">=</span> <span class="dv">3</span><span class="op">*</span>ini<span class="op">+</span><span class="dv">3</span><span class="op">*</span>fin</span>
<span id="cb15-15"><a href="implementación-del-entramado.html#cb15-15" aria-hidden="true" tabindex="-1"></a>  colu <span class="op">=</span> <span class="dv">2</span><span class="op">*</span>(Ne<span class="op">*</span>[<span class="dv">0</span>]<span class="op">+</span>Ne<span class="op">*</span>[<span class="dv">1</span>]<span class="op">+</span>Ne<span class="op">*</span>[<span class="dv">2</span>])</span>
<span id="cb15-16"><a href="implementación-del-entramado.html#cb15-16" aria-hidden="true" tabindex="-1"></a>  ten_nod <span class="op">=</span> sps.coo_matrix((data, (fila, colu))).toarray()</span>
<span id="cb15-17"><a href="implementación-del-entramado.html#cb15-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-18"><a href="implementación-del-entramado.html#cb15-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Fuerzas y aceleración</span></span>
<span id="cb15-19"><a href="implementación-del-entramado.html#cb15-19" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-20"><a href="implementación-del-entramado.html#cb15-20" aria-hidden="true" tabindex="-1"></a>  fue_gra <span class="op">=</span> <span class="op">-</span><span class="fl">9.8</span><span class="op">*</span>m<span class="op">*</span>np.tile(np.array([<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">1</span>]),(N<span class="op">**</span><span class="dv">2</span>,<span class="dv">1</span>)) <span class="co"># Gravedad</span></span>
<span id="cb15-21"><a href="implementación-del-entramado.html#cb15-21" aria-hidden="true" tabindex="-1"></a>  visc <span class="op">=</span> <span class="op">-</span>gamma<span class="op">*</span>vel                                     <span class="co"># Amortiguación</span></span>
<span id="cb15-22"><a href="implementación-del-entramado.html#cb15-22" aria-hidden="true" tabindex="-1"></a>  acel <span class="op">=</span> (ten_nod <span class="op">+</span> fue_gra <span class="op">+</span> visc)<span class="op">/</span>m                   <span class="co"># Aceleración</span></span>
<span id="cb15-23"><a href="implementación-del-entramado.html#cb15-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-24"><a href="implementación-del-entramado.html#cb15-24" aria-hidden="true" tabindex="-1"></a>  acel[fijos,:] <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>]                               <span class="co"># Esquinas fijas</span></span>
<span id="cb15-25"><a href="implementación-del-entramado.html#cb15-25" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb15-26"><a href="implementación-del-entramado.html#cb15-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.concatenate((s[<span class="dv">3</span><span class="op">*</span>N<span class="op">**</span><span class="dv">2</span>:],acel.T.reshape(<span class="op">-</span><span class="dv">1</span>)))</span></code></pre></div>
</div>
<div id="integración-y-graficación" class="section level2 hasAnchor" number="4.3">
<h2><span class="header-section-number">4.3</span> Integración y graficación<a href="implementación-del-entramado.html#integración-y-graficación" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Una vez modelada la ecuación diferencial ya podemos proceder a integrarla usando por ejemplo el comando odeint de la librería Scipy. Para ello necesitamos dar adicionalmente un intervalo de tiempo discreto y una condición inicial.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="implementación-del-entramado.html#cb16-1" aria-hidden="true" tabindex="-1"></a>px, py <span class="op">=</span> np.meshgrid(np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,N),np.linspace(<span class="dv">0</span>,<span class="dv">1</span>,N))</span>
<span id="cb16-2"><a href="implementación-del-entramado.html#cb16-2" aria-hidden="true" tabindex="-1"></a>s0 <span class="op">=</span> np.concatenate((px.reshape(<span class="op">-</span><span class="dv">1</span>), py.reshape(<span class="op">-</span><span class="dv">1</span>),np.zeros(N<span class="op">**</span><span class="dv">2</span>),np.zeros(<span class="dv">3</span><span class="op">*</span>N<span class="op">**</span><span class="dv">2</span>)))</span>
<span id="cb16-3"><a href="implementación-del-entramado.html#cb16-3" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> np.linspace(<span class="dv">0</span>,<span class="dv">10</span>,<span class="dv">2000</span>)</span>
<span id="cb16-4"><a href="implementación-del-entramado.html#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="implementación-del-entramado.html#cb16-5" aria-hidden="true" tabindex="-1"></a>sol <span class="op">=</span> odeint(dsdt,s0,t)</span></code></pre></div>
<p>Visualización del último instante</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="implementación-del-entramado.html#cb17-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb17-2"><a href="implementación-del-entramado.html#cb17-2" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.axes(projection<span class="op">=</span><span class="st">&#39;3d&#39;</span>)</span>
<span id="cb17-3"><a href="implementación-del-entramado.html#cb17-3" aria-hidden="true" tabindex="-1"></a>ax.axes.set_xlim3d(left<span class="op">=</span><span class="dv">0</span>, right<span class="op">=</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb17-4"><a href="implementación-del-entramado.html#cb17-4" aria-hidden="true" tabindex="-1"></a>ax.axes.set_ylim3d(bottom<span class="op">=</span><span class="dv">0</span>, top<span class="op">=</span><span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb17-5"><a href="implementación-del-entramado.html#cb17-5" aria-hidden="true" tabindex="-1"></a>ax.axes.set_zlim3d(bottom<span class="op">=-</span><span class="dv">1</span>, top<span class="op">=</span><span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb17-6"><a href="implementación-del-entramado.html#cb17-6" aria-hidden="true" tabindex="-1"></a>ax.view_init(<span class="dv">60</span>, <span class="dv">80</span>)<span class="op">;</span></span>
<span id="cb17-7"><a href="implementación-del-entramado.html#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="implementación-del-entramado.html#cb17-8" aria-hidden="true" tabindex="-1"></a>sol_fin <span class="op">=</span> sol[<span class="op">-</span><span class="dv">1</span>,:]</span>
<span id="cb17-9"><a href="implementación-del-entramado.html#cb17-9" aria-hidden="true" tabindex="-1"></a>pos <span class="op">=</span> np.reshape(sol_fin[:<span class="dv">3</span><span class="op">*</span>N<span class="op">**</span><span class="dv">2</span>],(<span class="dv">3</span>,N<span class="op">**</span><span class="dv">2</span>)).T</span>
<span id="cb17-10"><a href="implementación-del-entramado.html#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb17-11"><a href="implementación-del-entramado.html#cb17-11" aria-hidden="true" tabindex="-1"></a>  ax.plot3D(pos[i<span class="op">*</span>N:(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>N,<span class="dv">0</span>], pos[i<span class="op">*</span>N:(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>N:,<span class="dv">1</span>], pos[i<span class="op">*</span>N:(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>N,<span class="dv">2</span>],<span class="st">&#39;bo-&#39;</span>)</span>
<span id="cb17-12"><a href="implementación-del-entramado.html#cb17-12" aria-hidden="true" tabindex="-1"></a>  ax.plot3D(pos[i:N<span class="op">**</span><span class="dv">2</span>:N,<span class="dv">0</span>], pos[i:N<span class="op">**</span><span class="dv">2</span>:N,<span class="dv">1</span>], pos[i:N<span class="op">**</span><span class="dv">2</span>:N,<span class="dv">2</span>],<span class="st">&#39;b-&#39;</span>)</span></code></pre></div>
<p><img src="bookdown_intro_files/figure-html/unnamed-chunk-15-13.png" width="672" /></p>

</div>
<div id="espectro-del-laplaciano" class="section level2 hasAnchor" number="4.4">
<h2><span class="header-section-number">4.4</span> Espectro del Laplaciano<a href="implementación-del-entramado.html#espectro-del-laplaciano" class="anchor-section" aria-label="Anchor link to header"></a></h2>
<p>Hemos visto tres familias de problemas relacionados con el operador lineal <span class="math inline">\(u \mapsto Lu = \operatorname{div}(aDu)\)</span>:</p>
<ul>
<li><p><strong>Elíptico:</strong> <span class="math inline">\(\operatorname{div}(aDu) = f\)</span>,</p></li>
<li><p><strong>Parabólico:</strong> <span class="math inline">\(\p_t u = \operatorname{div}(aDu) + f\)</span>,</p></li>
<li><p><strong>Hiperbólico:</strong> <span class="math inline">\(\p_t^2 u = \operatorname{div}(aDu) + f\)</span>.</p></li>
</ul>
<p>Como tales, la descomposición espectral de <span class="math inline">\(L\)</span> trivializa el cálculo de las soluciones. A continuación daremos un breve recorrido a la teoría discreta de Fourier con la cual podemos clarificar como resolver cada uno de estos problemas.</p>
<p>Para <span class="math inline">\(a:E\to (0,\infty)\)</span> la composición dada por <span class="math inline">\(Lu = \operatorname{div}(aDu)\)</span> es un operador simétrico, negativo semi-definido. La simetría es una aplicación de la fórmula de integración por partes, bien sea usando que
<span class="math display">\[
(\operatorname{div} \operatorname{diag}(a) D)^T = D^T \operatorname{diag}(a)^T \operatorname{div}^T = (-\operatorname{div})  \operatorname{diag}(a)(-D) = \operatorname{div}\operatorname{diag}(a)D,
\]</span>
o en términos de las sumas
<span class="math display">\[
\sum_{x\in V} v(x)\operatorname{div}(aDu)(x) = -\sum_{e\in E} Dv(e)Du(e)a(e) = \sum_{x\in V} u(x)\operatorname{div}(aDv)(x).
\]</span>
La no-positividad la verificamos tomando <span class="math inline">\(v=u\)</span> tal que
<span class="math display">\[\begin{align}
\label{eq:no_pos}
\sum_{x\in V} u(x)\operatorname{div}(aDu)(x) = -\sum_{e\in E} (Du(e))^2a(e) \leq 0.
\end{align}\]</span></p>
<p>Gracias al sabemos que <span class="math inline">\(L\)</span> es diagonalizable, sus autovalores son reales no-positivos y además posee una base de autofunciones ortogonales. Denotemos por <span class="math inline">\(\phi_0,\ldots,\phi_{M-1}\)</span> a una base ortogonal con autovalores <span class="math inline">\(-\l_0,\ldots,-\l_{M-1}\)</span> respectivamente.</p>
<p>Gracias a la identidad <span class="math inline">\(\eqref{eq:no_pos}\)</span> vemos además que <span class="math inline">\(\operatorname{div}(aDu)=0\)</span> si y solo si <span class="math inline">\(Du=0\)</span>. Si <span class="math inline">\(G\)</span> es conexo entonces esto solamente se cumple para las funciones constantes. En otras palabras, <span class="math inline">\(\l=0\)</span> es un autovalor simple cuyo autoespacio consiste de las funciones constantes. En general, <span class="math inline">\(\l=0\)</span> es un autovalor de <span class="math inline">\(L\)</span> cuya multiplicidad geométrica es igual al número de componentes conexas de <span class="math inline">\(G\)</span>.</p>
<p></p>
<p>Gracias a la ortogonalidad podemos calcular la descomposición de una función arbitraria usando productos internos. Esta se conoce como la .</p>
<p>Dado que
<span class="math display">\[
u = \sum_{j=0}^{M-1} \hat u_j \phi_j
\]</span>
tenemos que tomando en ambos lados el producto interno con <span class="math inline">\(\phi_j\)</span> obtenemos que
<span class="math display">\[
\hat u_j = \frac{1}{\|\phi_j\|^2}\sum_{x\in V} u(x) \overline{\phi_j(x)}.
\]</span>
Los coeficientes <span class="math inline">\(\hat u_j\)</span> se conocen como los .</p>
<p>Retomemos los distintos problemas que anunciamos al principio de esta sección.</p>
<p>Dada la descomposición
<span class="math display">\[
f = \sum_{j=0}^{M-1} \hat f_j\phi_j, \qquad \hat f_j = \frac{1}{\|\phi_j\|^2}\sum_{x\in V} f(x)\overline{\phi_j(x)},
\]</span>
tenemos que <span class="math inline">\(u = \sum_{j=0}^{M-1} \hat u_j\phi_j\)</span> satisface <span class="math inline">\(Lu=f\)</span> si y solo si para todo <span class="math inline">\(j\in\{0,\ldots,(M-1)\}\)</span>
<span class="math display">\[
-\l_j \hat u_j = \hat f_j.
\]</span></p>
<p>Recordemos la hipótesis de conexidad para <span class="math inline">\(G\)</span> la cual garantiza que <span class="math inline">\(\l_0=0\)</span> es un autovalor simple cuyo autoespacio son las funciones constantes generadas por <span class="math inline">\(\phi_0=1\)</span>. Para <span class="math inline">\(j\neq 0\)</span> tenemos <span class="math inline">\(\l_j &gt; 0\)</span> por lo cual <span class="math inline">\(\hat u_j = -\hat f_j/\l_j\)</span>. Para <span class="math inline">\(j=0\)</span> tenemos sin embargo que <span class="math inline">\(\l_0=0\)</span> en cuyo caso la ecuación tiene solución solamente si se da la condición de ortogonalidad <span class="math inline">\(f\perp \phi_0\)</span>, equivalente a decir que
<span class="math display">\[
\sum_{x\in V} f(x) = 0.
\]</span>
Bajo esta hipótesis, el correspondiente coeficiente <span class="math inline">\(\hat u_0\)</span> es arbitrario.</p>
<p>Bajo la condición anterior para <span class="math inline">\(f\)</span>, tenemos que las soluciones de <span class="math inline">\(Lu=f\)</span> están dadas por
<span class="math display">\[
u(x) = c - \sum_{j=1}^{M-1} \frac{\hat f_j}{\l_j}\phi_j(x) = c - \sum_{j=1}^{M-1} \frac{1}{\l_j\|\phi_j\|^2}\1\sum_{y\in V} f(y)\overline{\phi_j(y)}\2\phi_j(x)
\]</span>
El término constante es la solución homogénea del sistema. El segundo es una solución particular la cual podemos reescribir como
<span class="math display">\[
u_p(x) := -\sum_{y\in V} G(x,y)f(y), \qquad G(x,y) := \sum_{j=1}^{M-1} \frac{\phi_j(x)\overline{\phi_j(y)}}{\|\phi_j\|^2}\l_j^{-1}.
\]</span></p>
<p>El sistema <span class="math inline">\(\p_t u = Lu+f\)</span> se reduce a un sistema de ecuaciones diferenciales ordinarias desacopladas
<span class="math display">\[
\hat u_j&#39; = -\l_j \hat u_j + \hat f_j
\]</span>
Usando por ejemplo la técnica del factor integrante obtenemos
<span class="math display">\[\begin{align*}
\hat u_j(t) &amp;= \hat u_j(0)e^{-\l_j t} + \int_0^t \hat f_j(s)e^{-\l_j(t-s)}ds\\
&amp;= \frac{1}{\|\phi_j\|^2}\sum_{y=1}^M \1u(y,0)\overline{\phi_j(y)}e^{-\l_j t} + \int_0^t f(y,s)\overline{\phi_j(y)}e^{-\l_j(t-s)}ds\2
\end{align*}\]</span></p>
<p>Agrupando los términos para la solución concluimos que
<span class="math display">\[
u(x,t) = \sum_{y\in V} u(y,0)H(x,y,t) + \int_0^t\sum_{y\in V} f(y,s)H(x,y,t-s)ds
\]</span>
donde
<span class="math display">\[
H(x,y,t) := \sum_{j=0}^{M-1} \frac{\phi_j(x)\overline{\phi_j(y)}}{\|\phi_j\|^2}e^{-\l_j t} = \frac{1}{M} + \sum_{j=1}^{M-1} \frac{\phi_j(x)\overline{\phi_j(y)}}{\|\phi_j\|^2}e^{-\l_j t}.
\]</span></p>
% \begin{center}
% \colorbox[HTML]{E5F3CC}{
% \begin{minipage}[c]{450px}
%
<p>\end{minipage}}
\end{center}</p>
<p>El sistema <span class="math inline">\(\p_t^2 u = Lu+f\)</span> también se reduce a un sistema de ecuaciones desacopladas de segundo orden
<span class="math display">\[
\hat u_j&#39;&#39; = -\l_j \hat u_j + \hat f_j
\]</span>
Tenemos así que <span class="math inline">\(\hat u_j(t)\)</span> se puede calcular en términos de su posición y velocidad inicial.</p>
<p>Para <span class="math inline">\(j=0\)</span>
<span class="math display">\[\begin{align*}
\hat u_0(t) &amp;= \hat u_0(0) + \hat u_0&#39;(0) t + \int_0^t \hat f_0(s)(t-s)ds.
\end{align*}\]</span></p>
<p>Para <span class="math inline">\(j\neq0\)</span> denotamos la frecuencia <span class="math inline">\(\w_j=\sqrt{\l_j}\)</span> tal que
<span class="math display">\[\begin{align*}
\hat u_j(t) &amp;= \hat u_j(0)\cos(\w_j t) + \hat u_j&#39;(0)\frac{\sen(\w_j t)}{\w_j} + \int_0^t \hat f_j(s)\frac{\sen(\w_j(t-s))}{\w_j}ds.
\end{align*}\]</span></p>
<p>Agrupando los términos para la solución concluimos que
<span class="math display">\[
u(x,t) = \sum_{j=0}^{M-1} u(y,0)W_1(x,y,t)+\p_t u(y,0)W_2(x,y,t) + \int_0^t f(y,s)W_2(x,y,t-s)ds
\]</span>
donde
<span class="math display">\[\begin{align*}
W_1(x,y,t) &amp;:= \sum_{j=0}^{M-1} \frac{\phi_j(x)\overline{\phi_j(y)}}{\|\phi_j\|^2}\cos(\w_j t), \\
W_2(x,y,t) &amp;:= \frac{t}{M} + \sum_{j=1}^{M-1} \frac{\phi_j(x)\overline{\phi_j(y)}}{\|\phi_j\|^2}\frac{\sen(\w_j t)}{\w_j}.
\end{align*}\]</span></p>
<p>% En los tres problemas que hemos analizado hemos encontrado que las soluciones aparecen en términos de un núcleo de la forma
% <span class="math display">\[
% N(x,y) = \sum_{j=0}^{M-1} \frac{\phi_j(x)\overline{\phi_j(y)}}{\|\phi_j\|^2}p_j.
% \]</span>
% Verificamos fácilmente la identidad de simetría dado que <span class="math inline">\(p_j\in \mathbb R\)</span>
% <span class="math display">\[
% N(x,y) = \overline{N(y,x)}.
% \]</span>
% Si además tomamos a las autofunciones <span class="math inline">\(\phi_j\)</span> como funciones reales entonces
% <span class="math display">\[
% N(x,y) = N(y,x).
% \]</span></p>
<p>% En algunos casos veremos que <span class="math inline">\(\phi_j(x)\overline{\phi_j(x)}=1\)</span> de donde se tiene que
% <span class="math display">\[
% N(x,x) =  \sum_{j=0}^{M-1} \frac{}{\|\phi_j\|^2}p_j.
% \]</span></p>
<p>En esta sección veremos como resolver el problema presentado en la siguiente caricatura de Randall Munroe autor de .</p>
<p>La resistencia efectiva se define de la siguiente forma. Etiquetemos primero los nodos de la red por <span class="math inline">\((x,y) \in \Z^2\)</span> tales que los nodos marcados son el origen <span class="math inline">\((0,0)\)</span> y <span class="math inline">\((2,1)\)</span>. Se fija un potencial <span class="math inline">\(u\)</span> sobre la red tal que <span class="math inline">\(u(0,0)=0\)</span>, <span class="math inline">\(u(2,1)=1\)</span>, mientras que en los demás nodos <span class="math inline">\(u\)</span> es armónica, es decir que para <span class="math inline">\((x,y) \in \Z^2 \sm \{(0,0),(2,1)\}\)</span>
<span class="math display">\[
\D u(x,y) = u(x-1,y) + u(x+1,y) + u(x,y-1) + u(x,y+1) - 4u(x,y) = 0.
\]</span>
Para que <span class="math inline">\(u\)</span> esté definida de forma unívoca hay que pedir adicionalmente que <span class="math inline">\(u\to 0\)</span> cuando <span class="math inline">\(|(x,y)|\to \infty\)</span>. Desde una perspectiva física esta condición en infinito es la más natural.</p>
<p>La corriente <span class="math inline">\(i\)</span> que sale del origen es la divergencia de <span class="math inline">\(u\)</span> en dicho punto, <span class="math inline">\(i= \operatorname{div} u(0,0)\)</span>. Este es a su vez la corriente que entra en el vértice <span class="math inline">\((2,1)\)</span> la cual se calcula de igual forma como <span class="math inline">\(i = -\operatorname{div} u(2,1)\)</span>. Si buscamos simplificar la red por el caso más sencillo que conecta a <span class="math inline">\((0,0)\)</span> y <span class="math inline">\((2,1)\)</span>, es decir el grafo con solamente estos dos vértices y una arista entre ellos, entonces la resistencia efectiva <span class="math inline">\(R\)</span> es aquella que debemos dar a esta única conexión para que la corriente siga siendo <span class="math inline">\(i\)</span> bajo el mismo potencial. En otras palabras <span class="math inline">\(R = 1/i\)</span>.</p>
<p>Como primer paso veremos como calcular el potencial análogo en el toro <span class="math inline">\(V_{N} = (\Z/N\Z)^2\)</span>, es decir un problema periódico donde identificamos las coordenadas enteras módulo <span class="math inline">\(N\gg1\)</span>. Cuando <span class="math inline">\(N\to \infty\)</span> el potencial eléctrico converge al potencial en <span class="math inline">\(\Z^2\)</span>. Este límite, a pesar de ser intuitivo, amerita una demostración que no presentaremos dado que buscamos enfatizar otras ideas por el momento. La ventaja de esta aproximación es que ahora nuestra ecuación es un problema de álgebra lineal en un espacio de dimensión <span class="math inline">\(N^2-2\)</span>
<span class="math display">\[
\D u = 0 \text{ en } V_{N}\sm \{(0,0),(2,1)\}, \qquad u(0,0)=0,\qquad u(2,1)=1.
\]</span></p>
<p>De las discusiones previas sabemos que a partir de la descomposición espectral del Laplaciano en <span class="math inline">\(V_{N}\)</span> podríamos calcular en cambio una solución particular de
<span class="math display">\[
\D v = \mathbbm \mathbbm 1_{(0,0)}-\mathbbm \mathbbm 1_{(2,1)} \text{ en } V_{N}.
\]</span>
Notemos que el lado derecho es de hecho perpendicular a las constantes, lo cual garantiza la existencia de soluciones. Para obtener <span class="math inline">\(u\)</span> a partir de <span class="math inline">\(v\)</span> verificamos que
<span class="math display">\[
u(x,y) = \frac{v(x,y)-v(0,0)}{v(2,1)-v(0,0)}
\]</span>
satisface la ecuación requerida y entonces
<span class="math display">\[
R_N = \frac{1}{\operatorname{div} u(0,0)} = \frac{v(2,1)-v(0,0)}{\operatorname{div} v(0,0)} = v(2,1)-v(0,0).
\]</span>
Nuestra estrategia será entonces calcular el límite de esta expresión cuando <span class="math inline">\(N\to\infty\)</span>.</p>
<p>Procedamos a calcular el espectro del Laplaciano sobre el toro (Ejercicio <span class="math inline">\(\ref{ejer:toro}\)</span>). Asumamos la hipótesis de
<span class="math display">\[
\phi(x,y) = \a(x)\b(y).
\]</span>
Este tipo de funciones toman ventaja de la simetría del problema con lo cual el Laplaciano se simplifica como operadores discretos más sencillos para cada factor
<span class="math display">\[
\D \phi(x,y) = \a(x)(\b(y-1)-2\b(y)+\b(y+1)) + (\a(x-1)-2\a(x)+\a(x+1))\b(y).
\]</span></p>
<p>Si <span class="math inline">\(\a\)</span> y <span class="math inline">\(\b\)</span> son autofunciones del Laplaciano en el grafo cíclico de tamaño <span class="math inline">\(N\)</span>, entonces <span class="math inline">\(\phi\)</span> es una autofunción en el toro. Tomemos de esta forma la base de Fourier
<span class="math display">\[
\phi_{k,l}(x,y) = \w^{kx+ly}, \qquad \w = e^{2\pi i/N}, \qquad (k,l)\in\{0,1,\ldots,(N-1)\}^2,
\]</span>
con autovalores <span class="math inline">\(-\l_{k,l}\)</span> tal que
<span class="math display">\[
\l_{k,l} := 4(\sen^2(\pi k/N)+\sen^2(\pi l/N)),
\]</span>
y normas
<span class="math display">\[
\|\phi_{k,l}\|^2=\sum_{(x,y)\in V_N} \phi_{k,l}(x,y)\overline{\phi_{k,l}(x,y)} = N^2.
\]</span></p>
<p>Finalmente reconstruimos la solución particular usando la fórmula de representación</p>
<p><span class="math display">\[\begin{align*}
v(x,y) &amp;= -\sum_{(x&#39;,y&#39;) \in V_N} K(x,y;x&#39;,y&#39;)(\mathbbm 1_{(0,0)}-\mathbbm 1_{(2,1)})(x&#39;,y&#39;) = K(x,y;2,1)-K(x,y;0,0).
\end{align*}\]</span>
donde para <span class="math inline">\(\w = e^{2\pi i/N}\)</span>
<span class="math display">\[
K(x,y;x&#39;,y&#39;) = \frac{1}{N^2}\sum_{(k,l)\neq (0,0)} \frac{\phi_{k,l}(x,y)\overline{\phi_{k,l}(x&#39;,y&#39;)}}{\l_{k,l}} = \frac{1}{4N^2}\sum_{(k,l)\neq (0,0)} \frac{\w^{k(x-x&#39;)+l(y-y&#39;)}}{\sen^2(\pi k/N)+\sen^2(\pi l/N)}.
\]</span></p>
<p>La resistencia efectiva es calculada así por
<span class="math display">\[\begin{align*}
R &amp;= v(2,1)-v(0,0),\\
&amp;= K(2,1;2,1)-K(2,1;0,0) - K(0,0;2,1)+K(0,0;0,0),\\
&amp;= \frac{1}{2N^2} \sum_{(k,l)\neq (0,0)} \frac{1-\cos((2k+l)2\pi/N)}{\sen^2(\pi k/N)+\sen^2(\pi l/N)},\\
&amp;= \frac{1}{N^2} \sum_{(k,l)\neq (0,0)} \frac{\sen^2((2k+l)\pi/N)}{\sen^2(\pi k/N)+\sen^2(\pi l/N)}.
\end{align*}\]</span>
En el límite podemos entonces calcular <span class="math inline">\(R\)</span> por la integral de Riemann
<span class="math display">\[
R = \frac{1}{\pi^2}\int_0^\pi\int_0^\pi \frac{\sen^2(2x+y)}{\sen^2x+\sen^2y}dydx
\]</span></p>
<p>{Integración numérica}</p>

</div>
</div>










            </section>

          </div>
        </div>
      </div>
<a href="dinámica.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page"><i class="fa fa-angle-left"></i></a>

    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"whatsapp": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/USERNAME/REPO/edit/BRANCH/04-entramado.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"view": {
"link": "https://github.com/hchanglara/metodos_mat_aplicadas/blob/master/04-entramado.Rmd",
"text": null
},
"download": ["bookdown_intro.pdf", "bookdown_intro.epub"],
"search": {
"engine": "fuse",
"options": null
},
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
